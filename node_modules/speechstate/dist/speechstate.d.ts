import { Settings, SpeechStateEvent } from "./types";
interface SSContext {
    settings: Settings;
    audioContext?: AudioContext;
    asrRef?: any;
    ttsRef?: any;
}
declare const speechstate: import("xstate").StateMachine<SSContext, SpeechStateEvent, {
    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
    }, import("xstate").Values<{
        getToken: {
            src: "getToken";
            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
            id: string;
        };
        createEventsFromStream: {
            src: "createEventsFromStream";
            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
            id: string;
        };
        ponyfill: {
            src: "ponyfill";
            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
            id: string;
        };
        start: {
            src: "start";
            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
            id: string;
        };
    }>, import("xstate").Values<{
        ttsStop: {
            type: "ttsStop";
            params: unknown;
        };
        addFiller: {
            type: "addFiller";
            params: {};
        };
        assignCurrentVoice: {
            type: "assignCurrentVoice";
            params: {};
        };
        sendParentCurrentPersona: {
            type: "sendParentCurrentPersona";
            params: {};
        };
    }>, import("xstate").Values<{
        bufferContainsUtterancePartReadyToBeSpoken: {
            type: "bufferContainsUtterancePartReadyToBeSpoken";
            params: unknown;
        };
        bufferIsNonEmpty: {
            type: "bufferIsNonEmpty";
            params: unknown;
        };
    }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
        Ready?: "Idle" | {
            BufferedSpeaker?: Required<{
                Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                    Speak?: "Go" | "Paused";
                };
            }>;
            Speaking?: "Go" | "Paused";
        };
    }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
        readonly id: "tts";
        readonly context: ({ input }: {
            spawn: {
                <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                } extends infer T ? T extends {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                } ? T extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                    src: "createEventsFromStream";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                    id: string;
                } extends infer T_1 ? T_1 extends {
                    src: "createEventsFromStream";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                    id: string;
                } ? T_1 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_1["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_1["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } extends infer T_2 ? T_2 extends {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } ? T_2 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_2["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_2["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                    src: "start";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                    id: string;
                } extends infer T_3 ? T_3 extends {
                    src: "start";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                    id: string;
                } ? T_3 extends {
                    src: TSrc;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_3["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_3["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    createEventsFromStream: {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    start: {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                        id: string;
                    };
                }>, "src", TSrc>["logic"]>;
                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                    id?: never;
                    systemId?: string;
                    input?: import("xstate").InputFrom<TLogic>;
                    syncSnapshot?: boolean;
                }): import("xstate").ActorRefFromLogic<TLogic>;
            };
            input: import("./types").TTSInit;
            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
        }) => {
            ttsDefaultVoice: string;
            ttsLexicon: string;
            audioContext: AudioContext;
            azureCredentials: string | import("./types").AzureSpeechCredentials;
            azureRegion: string;
            buffer: string;
        };
        readonly initial: "GetToken";
        readonly on: {
            readonly READY: {
                readonly target: ".Ready";
                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                    type: "READY";
                    value: {
                        wsaTTS: SpeechSynthesis;
                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                    };
                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    createEventsFromStream: {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    start: {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                        id: string;
                    };
                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                    type: "READY";
                    value: {
                        wsaTTS: SpeechSynthesis;
                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                    };
                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
            };
            readonly ERROR: {
                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                    type: "ERROR";
                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
            };
        };
        readonly states: {
            readonly Ready: {
                readonly initial: "Idle";
                readonly states: {
                    readonly Idle: {
                        readonly on: {
                            readonly SPEAK: readonly [{
                                readonly target: "BufferedSpeaker";
                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                    type: "SPEAK";
                                    value: import("./types").Agenda;
                                }>) => boolean;
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "SPEAK";
                                    value: import("./types").Agenda;
                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>;
                            }, {
                                readonly target: "Speaking";
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "SPEAK";
                                    value: import("./types").Agenda;
                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>;
                            }];
                        };
                    };
                    readonly BufferedSpeaker: {
                        readonly type: "parallel";
                        readonly invoke: {
                            readonly id: "createEventsFromStream";
                            readonly src: "createEventsFromStream";
                            readonly input: ({ context }: {
                                context: import("./types").TTSContext;
                                event: import("./types").TTSEvent;
                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                            }) => import("./types").Agenda;
                        };
                        readonly on: {
                            readonly STOP: {
                                readonly target: "Idle";
                            };
                            readonly SPEAK_COMPLETE: readonly [{
                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                    type: "SPEAK_COMPLETE";
                                }, undefined, any>;
                                readonly target: "Idle";
                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "SPEAK_COMPLETE";
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                            }];
                        };
                        readonly states: {
                            readonly Buffer: {
                                readonly initial: "BufferIdle";
                                readonly on: {
                                    readonly STREAMING_SET_VOICE: {
                                        readonly actions: "assignCurrentVoice";
                                    };
                                    readonly STREAMING_SET_PERSONA: {
                                        readonly actions: "sendParentCurrentPersona";
                                    };
                                };
                                readonly states: {
                                    readonly BufferIdle: {
                                        readonly id: "BufferIdle";
                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                        readonly on: {
                                            readonly STREAMING_CHUNK: {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                    type: "STREAMING_CHUNK";
                                                    value: string;
                                                }, import("./types").TTSEvent>) => void];
                                                readonly target: "Buffering";
                                            };
                                        };
                                    };
                                    readonly Buffering: {
                                        readonly id: "Buffering";
                                        readonly on: {
                                            readonly STREAMING_CHUNK: readonly [{
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                    type: "STREAMING_CHUNK";
                                                    value: string;
                                                }, import("./types").TTSEvent>) => void];
                                                readonly target: "Buffering";
                                                readonly reenter: true;
                                            }];
                                            readonly STREAMING_DONE: readonly [{
                                                readonly target: "BufferingDone";
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                    type: "STREAMING_DONE";
                                                }, import("./types").TTSEvent>) => void];
                                            }];
                                        };
                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly BufferingDone: {
                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                        readonly id: "BufferingDone";
                                    };
                                };
                            };
                            readonly Speaker: {
                                readonly initial: "SpeakingIdle";
                                readonly states: {
                                    readonly SpeakingIdle: {
                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                        readonly always: readonly [{
                                            readonly target: "Speak";
                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>];
                                        }, {
                                            readonly target: "PrepareSpeech";
                                            readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                        }];
                                        readonly after: {
                                            readonly FILLER_DELAY: {
                                                readonly target: "SpeakingIdle";
                                                readonly reenter: true;
                                                readonly actions: "addFiller";
                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                            };
                                        };
                                    };
                                    readonly PrepareSpeech: {
                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                        readonly always: readonly [{
                                            readonly target: "Speak";
                                        }];
                                    };
                                    readonly Speak: {
                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                        readonly initial: "Go";
                                        readonly on: {
                                            readonly TTS_STARTED: {
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "TTS_STARTED";
                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                            };
                                            readonly SPEAK_COMPLETE: readonly [{
                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                    type: "SPEAK_COMPLETE";
                                                }, undefined, any>;
                                                readonly target: "SpeakingIdle";
                                            }, {
                                                readonly guard: "bufferIsNonEmpty";
                                                readonly target: "SpeakingIdle";
                                            }];
                                        };
                                        readonly states: {
                                            readonly Go: {
                                                readonly invoke: {
                                                    readonly src: "start";
                                                    readonly input: ({ context }: {
                                                        context: import("./types").TTSContext;
                                                        event: import("./types").TTSEvent;
                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                    }) => {
                                                        wsaTTS: SpeechSynthesis;
                                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                        ttsLexicon: string;
                                                        voice: string;
                                                        utterance: string;
                                                    };
                                                };
                                                readonly on: {
                                                    readonly CONTROL: "Paused";
                                                };
                                                readonly exit: "ttsStop";
                                            };
                                            readonly Paused: {
                                                readonly on: {
                                                    readonly CONTROL: "Go";
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                    readonly Speaking: {
                        readonly initial: "Go";
                        readonly on: {
                            readonly STOP: {
                                readonly target: "Idle";
                            };
                            readonly TTS_STARTED: {
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "TTS_STARTED";
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                            };
                            readonly SPEAK_COMPLETE: {
                                readonly target: "Idle";
                            };
                        };
                        readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                        readonly states: {
                            readonly Go: {
                                readonly invoke: {
                                    readonly src: "start";
                                    readonly input: ({ context }: {
                                        context: import("./types").TTSContext;
                                        event: import("./types").TTSEvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                    }) => {
                                        wsaTTS: SpeechSynthesis;
                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                        ttsLexicon: string;
                                        voice: string;
                                        utterance: string;
                                    };
                                };
                                readonly on: {
                                    readonly CONTROL: "Paused";
                                };
                                readonly exit: "ttsStop";
                            };
                            readonly Paused: {
                                readonly on: {
                                    readonly CONTROL: "Go";
                                };
                            };
                        };
                    };
                };
            };
            readonly Fail: {};
            readonly GetToken: {
                readonly invoke: {
                    readonly id: "getAuthorizationToken";
                    readonly input: ({ context }: {
                        context: any;
                    }) => {
                        credentials: any;
                    };
                    readonly src: "getToken";
                    readonly onDone: {
                        readonly target: "Ponyfill";
                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                            getToken: {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            };
                            createEventsFromStream: {
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                id: string;
                            };
                            ponyfill: {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            };
                            start: {
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                id: string;
                            };
                        }>, never, never, never, never>];
                    };
                    readonly onError: {
                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                        readonly target: "Fail";
                    };
                };
            };
            readonly Ponyfill: {
                readonly invoke: {
                    readonly id: "ponyTTS";
                    readonly src: "ponyfill";
                    readonly input: ({ context }: {
                        context: import("./types").TTSContext;
                        event: import("./types").TTSEvent;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                    }) => {
                        audioContext: AudioContext;
                        azureAuthorizationToken: string;
                        azureRegion: string;
                    };
                };
            };
        };
    }>> | import("xstate").ActorRefFromLogic<import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
            query: string;
        }, import("xstate").EventObject>>;
    }, import("xstate").Values<{
        getToken: {
            src: "getToken";
            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
            id: string;
        };
        ponyfill: {
            src: "ponyfill";
            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
            id: string;
        };
        recStart: {
            src: "recStart";
            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
            id: string;
        };
        nluPromise: {
            src: "nluPromise";
            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                query: string;
            }, import("xstate").EventObject>;
            id: string;
        };
    }>, {
        type: "recStop";
        params: unknown;
    }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
        Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
    }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
        readonly id: "asr";
        readonly context: ({ input }: {
            spawn: {
                <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                } extends infer T_4 ? T_4 extends {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                } ? T_4 extends {
                    src: TSrc_1;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_4["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_4["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_4 in import("xstate").RequiredActorOptions<T_4>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_4>>> : never : never : never) | ({
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } extends infer T_5 ? T_5 extends {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                } ? T_5 extends {
                    src: TSrc_1;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_5["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_5["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_5 in import("xstate").RequiredActorOptions<T_5>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_5>>> : never : never : never) | ({
                    src: "recStart";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                    id: string;
                } extends infer T_6 ? T_6 extends {
                    src: "recStart";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                    id: string;
                } ? T_6 extends {
                    src: TSrc_1;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_6["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_6["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_6 in import("xstate").RequiredActorOptions<T_6>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_6>>> : never : never : never) | ({
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } extends infer T_7 ? T_7 extends {
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                    }, import("xstate").EventObject>;
                    id: string;
                } ? T_7 extends {
                    src: TSrc_1;
                } ? import("xstate").ConditionalRequired<[options?: {
                    id?: T_7["id"];
                    systemId?: string;
                    input?: import("xstate").InputFrom<T_7["logic"]>;
                    syncSnapshot?: boolean;
                } & { [K_7 in import("xstate").RequiredActorOptions<T_7>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_7>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    recStart: {
                        src: "recStart";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, "src", TSrc_1>["logic"]>;
                <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                    id?: never;
                    systemId?: string;
                    input?: import("xstate").InputFrom<TLogic_1>;
                    syncSnapshot?: boolean;
                }): import("xstate").ActorRefFromLogic<TLogic_1>;
            };
            input: import("./types").ASRInit;
            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
        }) => {
            asrDefaultCompleteTimeout: number;
            asrDefaultNoInputTimeout: number;
            locale: string;
            audioContext: AudioContext;
            azureCredentials: string | import("./types").AzureSpeechCredentials;
            azureRegion: string;
            azureLanguageCredentials: import("./types").AzureLanguageCredentials;
            speechRecognitionEndpointId: string;
        };
        readonly initial: "GetToken";
        readonly on: {
            readonly READY: {
                readonly target: ".Ready";
                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                    type: "READY";
                    value: {
                        wsaASR: import("./types").MySpeechRecognition;
                        wsaGrammarList: import("./types").MySpeechGrammarList;
                    };
                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    recStart: {
                        src: "recStart";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                    type: "READY";
                    value: {
                        wsaASR: import("./types").MySpeechRecognition;
                        wsaGrammarList: import("./types").MySpeechGrammarList;
                    };
                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
            };
        };
        readonly states: {
            readonly Fail: {};
            readonly Ready: {
                readonly on: {
                    readonly START: {
                        readonly target: "Recognising";
                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "START";
                            value?: import("./types").RecogniseParameters;
                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                            getToken: {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            };
                            ponyfill: {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            };
                            recStart: {
                                src: "recStart";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                id: string;
                            };
                            nluPromise: {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                        }>, never, never, never, never>;
                    };
                };
            };
            readonly Recognising: {
                readonly initial: "WaitForRecogniser";
                readonly invoke: {
                    readonly id: "recStart";
                    readonly input: ({ context }: {
                        context: any;
                    }) => {
                        wsaASR: any;
                        wsaGrammarList: any;
                        locale: any;
                        phrases: any;
                    };
                    readonly src: "recStart";
                };
                readonly exit: "recStop";
                readonly on: {
                    readonly RESULT: {
                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "RESULT";
                            value: import("./types").Hypothesis[];
                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                            getToken: {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            };
                            ponyfill: {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            };
                            recStart: {
                                src: "recStart";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                id: string;
                            };
                            nluPromise: {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                        }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                            type: "RESULT";
                            value: import("./types").Hypothesis[];
                        }, undefined, import("./types").ASREvent>];
                        readonly target: ".Match";
                    };
                    readonly RECOGNISED: readonly [{
                        readonly target: ".NLURequest";
                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                            type: "RECOGNISED";
                        }>) => boolean;
                    }, {
                        readonly target: "Ready";
                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "RECOGNISED";
                        }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                    }];
                    readonly CONTROL: {
                        readonly target: "Paused";
                    };
                    readonly STOP: {
                        readonly target: "Ready";
                    };
                    readonly NOINPUT: {
                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                            type: "NOINPUT";
                        }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                        readonly target: "Ready";
                    };
                };
                readonly states: {
                    readonly WaitForRecogniser: {
                        readonly on: {
                            readonly STARTED: {
                                readonly target: "NoInput";
                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "STARTED";
                                    value: {
                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                    };
                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    recStart: {
                                        src: "recStart";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "STARTED";
                                    value: {
                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                    };
                                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                            };
                        };
                    };
                    readonly NoInput: {
                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                        readonly on: {
                            readonly STARTSPEECH: {
                                readonly target: "InProgress";
                                readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                    type: "STARTSPEECH";
                                }, undefined, import("./types").ASREvent>;
                            };
                        };
                        readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                    };
                    readonly InProgress: {
                        readonly entry: () => void;
                    };
                    readonly Match: {
                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                    };
                    readonly NLURequest: {
                        readonly invoke: {
                            readonly src: "nluPromise";
                            readonly input: ({ context }: {
                                context: import("./types").ASRContext;
                                event: import("./types").ASREvent;
                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                            }) => {
                                endpoint: string;
                                key: string;
                                projectName: string;
                                deploymentName: string;
                                query: string;
                            };
                            readonly onDone: readonly [{
                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                readonly target: "#asr.Ready";
                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                            }, {
                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                readonly target: "#asr.Ready";
                            }];
                            readonly onError: {
                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                readonly target: "#asr.Ready";
                            };
                        };
                    };
                };
            };
            readonly Paused: {
                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                readonly on: {
                    readonly CONTROL: {
                        readonly target: "Recognising";
                    };
                };
            };
            readonly GetToken: {
                readonly invoke: {
                    readonly id: "getAuthorizationToken";
                    readonly input: ({ context }: {
                        context: any;
                    }) => {
                        credentials: any;
                    };
                    readonly src: "getToken";
                    readonly onDone: {
                        readonly target: "Ponyfill";
                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                            getToken: {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            };
                            ponyfill: {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            };
                            recStart: {
                                src: "recStart";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                id: string;
                            };
                            nluPromise: {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            };
                        }>, never, never, never, never>];
                    };
                    readonly onError: {
                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                        readonly target: "Fail";
                    };
                };
            };
            readonly Ponyfill: {
                readonly invoke: {
                    readonly id: "ponyASR";
                    readonly src: "ponyfill";
                    readonly input: ({ context }: {
                        context: import("./types").ASRContext;
                        event: import("./types").ASREvent;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                    }) => {
                        azureRegion: string;
                        audioContext: AudioContext;
                        azureAuthorizationToken: string;
                        locale: string;
                        speechRecognitionEndpointId: string;
                    };
                };
            };
        };
    }>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>>;
}, import("xstate").Values<{
    audioContext: {
        src: "audioContext";
        logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
        id: string;
    };
    tts: {
        src: "tts";
        logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
            [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
        }, import("xstate").Values<{
            getToken: {
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            };
            createEventsFromStream: {
                src: "createEventsFromStream";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                id: string;
            };
            ponyfill: {
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                id: string;
            };
            start: {
                src: "start";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                id: string;
            };
        }>, import("xstate").Values<{
            ttsStop: {
                type: "ttsStop";
                params: unknown;
            };
            addFiller: {
                type: "addFiller";
                params: {};
            };
            assignCurrentVoice: {
                type: "assignCurrentVoice";
                params: {};
            };
            sendParentCurrentPersona: {
                type: "sendParentCurrentPersona";
                params: {};
            };
        }>, import("xstate").Values<{
            bufferContainsUtterancePartReadyToBeSpoken: {
                type: "bufferContainsUtterancePartReadyToBeSpoken";
                params: unknown;
            };
            bufferIsNonEmpty: {
                type: "bufferIsNonEmpty";
                params: unknown;
            };
        }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
            Ready?: "Idle" | {
                BufferedSpeaker?: Required<{
                    Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                    Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                        Speak?: "Go" | "Paused";
                    };
                }>;
                Speaking?: "Go" | "Paused";
            };
        }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
            readonly id: "tts";
            readonly context: ({ input }: {
                spawn: {
                    <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_8 ? T_8 extends {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    } ? T_8 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_8["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_8["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_8 in import("xstate").RequiredActorOptions<T_8>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_8>>> : never : never : never) | ({
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_9 ? T_9 extends {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                        id: string;
                    } ? T_9 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_9["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_9["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_9 in import("xstate").RequiredActorOptions<T_9>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_9>>> : never : never : never) | ({
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_10 ? T_10 extends {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } ? T_10 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_10["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_10["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_10 in import("xstate").RequiredActorOptions<T_10>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_10>>> : never : never : never) | ({
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_11 ? T_11 extends {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                        id: string;
                    } ? T_11 extends {
                        src: TSrc;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_11["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_11["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_11 in import("xstate").RequiredActorOptions<T_11>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_11>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, "src", TSrc>["logic"]>;
                    <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                        id?: never;
                        systemId?: string;
                        input?: import("xstate").InputFrom<TLogic>;
                        syncSnapshot?: boolean;
                    }): import("xstate").ActorRefFromLogic<TLogic>;
                };
                input: import("./types").TTSInit;
                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
            }) => {
                ttsDefaultVoice: string;
                ttsLexicon: string;
                audioContext: AudioContext;
                azureCredentials: string | import("./types").AzureSpeechCredentials;
                azureRegion: string;
                buffer: string;
            };
            readonly initial: "GetToken";
            readonly on: {
                readonly READY: {
                    readonly target: ".Ready";
                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                        type: "READY";
                        value: {
                            wsaTTS: SpeechSynthesis;
                            wsaUtt: import("./types").MySpeechSynthesisUtterance;
                        };
                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                        type: "READY";
                        value: {
                            wsaTTS: SpeechSynthesis;
                            wsaUtt: import("./types").MySpeechSynthesisUtterance;
                        };
                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                };
                readonly ERROR: {
                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                        type: "ERROR";
                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                };
            };
            readonly states: {
                readonly Ready: {
                    readonly initial: "Idle";
                    readonly states: {
                        readonly Idle: {
                            readonly on: {
                                readonly SPEAK: readonly [{
                                    readonly target: "BufferedSpeaker";
                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                        type: "SPEAK";
                                        value: import("./types").Agenda;
                                    }>) => boolean;
                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                        type: "SPEAK";
                                        value: import("./types").Agenda;
                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                }, {
                                    readonly target: "Speaking";
                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                        type: "SPEAK";
                                        value: import("./types").Agenda;
                                    }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                }];
                            };
                        };
                        readonly BufferedSpeaker: {
                            readonly type: "parallel";
                            readonly invoke: {
                                readonly id: "createEventsFromStream";
                                readonly src: "createEventsFromStream";
                                readonly input: ({ context }: {
                                    context: import("./types").TTSContext;
                                    event: import("./types").TTSEvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                }) => import("./types").Agenda;
                            };
                            readonly on: {
                                readonly STOP: {
                                    readonly target: "Idle";
                                };
                                readonly SPEAK_COMPLETE: readonly [{
                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                        type: "SPEAK_COMPLETE";
                                    }, undefined, any>;
                                    readonly target: "Idle";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                        type: "SPEAK_COMPLETE";
                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                }];
                            };
                            readonly states: {
                                readonly Buffer: {
                                    readonly initial: "BufferIdle";
                                    readonly on: {
                                        readonly STREAMING_SET_VOICE: {
                                            readonly actions: "assignCurrentVoice";
                                        };
                                        readonly STREAMING_SET_PERSONA: {
                                            readonly actions: "sendParentCurrentPersona";
                                        };
                                    };
                                    readonly states: {
                                        readonly BufferIdle: {
                                            readonly id: "BufferIdle";
                                            readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                            readonly on: {
                                                readonly STREAMING_CHUNK: {
                                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                        type: "STREAMING_CHUNK";
                                                        value: string;
                                                    }, import("./types").TTSEvent>) => void];
                                                    readonly target: "Buffering";
                                                };
                                            };
                                        };
                                        readonly Buffering: {
                                            readonly id: "Buffering";
                                            readonly on: {
                                                readonly STREAMING_CHUNK: readonly [{
                                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                        type: "STREAMING_CHUNK";
                                                        value: string;
                                                    }, import("./types").TTSEvent>) => void];
                                                    readonly target: "Buffering";
                                                    readonly reenter: true;
                                                }];
                                                readonly STREAMING_DONE: readonly [{
                                                    readonly target: "BufferingDone";
                                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                        type: "STREAMING_DONE";
                                                    }, import("./types").TTSEvent>) => void];
                                                }];
                                            };
                                            readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>];
                                        };
                                        readonly BufferingDone: {
                                            readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                            readonly id: "BufferingDone";
                                        };
                                    };
                                };
                                readonly Speaker: {
                                    readonly initial: "SpeakingIdle";
                                    readonly states: {
                                        readonly SpeakingIdle: {
                                            readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                            readonly always: readonly [{
                                                readonly target: "Speak";
                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>];
                                            }, {
                                                readonly target: "PrepareSpeech";
                                                readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                            }];
                                            readonly after: {
                                                readonly FILLER_DELAY: {
                                                    readonly target: "SpeakingIdle";
                                                    readonly reenter: true;
                                                    readonly actions: "addFiller";
                                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                };
                                            };
                                        };
                                        readonly PrepareSpeech: {
                                            readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>];
                                            readonly always: readonly [{
                                                readonly target: "Speak";
                                            }];
                                        };
                                        readonly Speak: {
                                            readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                            readonly initial: "Go";
                                            readonly on: {
                                                readonly TTS_STARTED: {
                                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                        type: "TTS_STARTED";
                                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                };
                                                readonly SPEAK_COMPLETE: readonly [{
                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                        type: "SPEAK_COMPLETE";
                                                    }, undefined, any>;
                                                    readonly target: "SpeakingIdle";
                                                }, {
                                                    readonly guard: "bufferIsNonEmpty";
                                                    readonly target: "SpeakingIdle";
                                                }];
                                            };
                                            readonly states: {
                                                readonly Go: {
                                                    readonly invoke: {
                                                        readonly src: "start";
                                                        readonly input: ({ context }: {
                                                            context: import("./types").TTSContext;
                                                            event: import("./types").TTSEvent;
                                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                        }) => {
                                                            wsaTTS: SpeechSynthesis;
                                                            wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                            ttsLexicon: string;
                                                            voice: string;
                                                            utterance: string;
                                                        };
                                                    };
                                                    readonly on: {
                                                        readonly CONTROL: "Paused";
                                                    };
                                                    readonly exit: "ttsStop";
                                                };
                                                readonly Paused: {
                                                    readonly on: {
                                                        readonly CONTROL: "Go";
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        readonly Speaking: {
                            readonly initial: "Go";
                            readonly on: {
                                readonly STOP: {
                                    readonly target: "Idle";
                                };
                                readonly TTS_STARTED: {
                                    readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                        type: "TTS_STARTED";
                                    }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                };
                                readonly SPEAK_COMPLETE: {
                                    readonly target: "Idle";
                                };
                            };
                            readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                            readonly states: {
                                readonly Go: {
                                    readonly invoke: {
                                        readonly src: "start";
                                        readonly input: ({ context }: {
                                            context: import("./types").TTSContext;
                                            event: import("./types").TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            wsaTTS: SpeechSynthesis;
                                            wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                            ttsLexicon: string;
                                            voice: string;
                                            utterance: string;
                                        };
                                    };
                                    readonly on: {
                                        readonly CONTROL: "Paused";
                                    };
                                    readonly exit: "ttsStop";
                                };
                                readonly Paused: {
                                    readonly on: {
                                        readonly CONTROL: "Go";
                                    };
                                };
                            };
                        };
                    };
                };
                readonly Fail: {};
                readonly GetToken: {
                    readonly invoke: {
                        readonly id: "getAuthorizationToken";
                        readonly input: ({ context }: {
                            context: any;
                        }) => {
                            credentials: any;
                        };
                        readonly src: "getToken";
                        readonly onDone: {
                            readonly target: "Ponyfill";
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>];
                        };
                        readonly onError: {
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                            readonly target: "Fail";
                        };
                    };
                };
                readonly Ponyfill: {
                    readonly invoke: {
                        readonly id: "ponyTTS";
                        readonly src: "ponyfill";
                        readonly input: ({ context }: {
                            context: import("./types").TTSContext;
                            event: import("./types").TTSEvent;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                        }) => {
                            audioContext: AudioContext;
                            azureAuthorizationToken: string;
                            azureRegion: string;
                        };
                    };
                };
            };
        }>;
        id: string;
    };
    asr: {
        src: "asr";
        logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
            [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                query: string;
            }, import("xstate").EventObject>>;
        }, import("xstate").Values<{
            getToken: {
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            };
            ponyfill: {
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                id: string;
            };
            recStart: {
                src: "recStart";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                id: string;
            };
            nluPromise: {
                src: "nluPromise";
                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                    query: string;
                }, import("xstate").EventObject>;
                id: string;
            };
        }>, {
            type: "recStop";
            params: unknown;
        }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
            Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
        }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
            readonly id: "asr";
            readonly context: ({ input }: {
                spawn: {
                    <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_12 ? T_12 extends {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    } ? T_12 extends {
                        src: TSrc_1;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_12["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_12["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_12 in import("xstate").RequiredActorOptions<T_12>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_12>>> : never : never : never) | ({
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_13 ? T_13 extends {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    } ? T_13 extends {
                        src: TSrc_1;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_13["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_13["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_13 in import("xstate").RequiredActorOptions<T_13>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_13>>> : never : never : never) | ({
                        src: "recStart";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_14 ? T_14 extends {
                        src: "recStart";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                        id: string;
                    } ? T_14 extends {
                        src: TSrc_1;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_14["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_14["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_14 in import("xstate").RequiredActorOptions<T_14>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_14>>> : never : never : never) | ({
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } extends infer T_15 ? T_15 extends {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    } ? T_15 extends {
                        src: TSrc_1;
                    } ? import("xstate").ConditionalRequired<[options?: {
                        id?: T_15["id"];
                        systemId?: string;
                        input?: import("xstate").InputFrom<T_15["logic"]>;
                        syncSnapshot?: boolean;
                    } & { [K_15 in import("xstate").RequiredActorOptions<T_15>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_15>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        recStart: {
                            src: "recStart";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, "src", TSrc_1>["logic"]>;
                    <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                        id?: never;
                        systemId?: string;
                        input?: import("xstate").InputFrom<TLogic_1>;
                        syncSnapshot?: boolean;
                    }): import("xstate").ActorRefFromLogic<TLogic_1>;
                };
                input: import("./types").ASRInit;
                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
            }) => {
                asrDefaultCompleteTimeout: number;
                asrDefaultNoInputTimeout: number;
                locale: string;
                audioContext: AudioContext;
                azureCredentials: string | import("./types").AzureSpeechCredentials;
                azureRegion: string;
                azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                speechRecognitionEndpointId: string;
            };
            readonly initial: "GetToken";
            readonly on: {
                readonly READY: {
                    readonly target: ".Ready";
                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                        type: "READY";
                        value: {
                            wsaASR: import("./types").MySpeechRecognition;
                            wsaGrammarList: import("./types").MySpeechGrammarList;
                        };
                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        recStart: {
                            src: "recStart";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                        type: "READY";
                        value: {
                            wsaASR: import("./types").MySpeechRecognition;
                            wsaGrammarList: import("./types").MySpeechGrammarList;
                        };
                    }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                };
            };
            readonly states: {
                readonly Fail: {};
                readonly Ready: {
                    readonly on: {
                        readonly START: {
                            readonly target: "Recognising";
                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "START";
                                value?: import("./types").RecogniseParameters;
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                        };
                    };
                };
                readonly Recognising: {
                    readonly initial: "WaitForRecogniser";
                    readonly invoke: {
                        readonly id: "recStart";
                        readonly input: ({ context }: {
                            context: any;
                        }) => {
                            wsaASR: any;
                            wsaGrammarList: any;
                            locale: any;
                            phrases: any;
                        };
                        readonly src: "recStart";
                    };
                    readonly exit: "recStop";
                    readonly on: {
                        readonly RESULT: {
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "RESULT";
                                value: import("./types").Hypothesis[];
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                type: "RESULT";
                                value: import("./types").Hypothesis[];
                            }, undefined, import("./types").ASREvent>];
                            readonly target: ".Match";
                        };
                        readonly RECOGNISED: readonly [{
                            readonly target: ".NLURequest";
                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                                type: "RECOGNISED";
                            }>) => boolean;
                        }, {
                            readonly target: "Ready";
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "RECOGNISED";
                            }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                        }];
                        readonly CONTROL: {
                            readonly target: "Paused";
                        };
                        readonly STOP: {
                            readonly target: "Ready";
                        };
                        readonly NOINPUT: {
                            readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "NOINPUT";
                            }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                            readonly target: "Ready";
                        };
                    };
                    readonly states: {
                        readonly WaitForRecogniser: {
                            readonly on: {
                                readonly STARTED: {
                                    readonly target: "NoInput";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "STARTED";
                                        value: {
                                            wsaASRinstance: import("./types").MySpeechRecognition;
                                        };
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        recStart: {
                                            src: "recStart";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "STARTED";
                                        value: {
                                            wsaASRinstance: import("./types").MySpeechRecognition;
                                        };
                                    }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                };
                            };
                        };
                        readonly NoInput: {
                            readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                            readonly on: {
                                readonly STARTSPEECH: {
                                    readonly target: "InProgress";
                                    readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                        type: "STARTSPEECH";
                                    }, undefined, import("./types").ASREvent>;
                                };
                            };
                            readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                        };
                        readonly InProgress: {
                            readonly entry: () => void;
                        };
                        readonly Match: {
                            readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                        };
                        readonly NLURequest: {
                            readonly invoke: {
                                readonly src: "nluPromise";
                                readonly input: ({ context }: {
                                    context: import("./types").ASRContext;
                                    event: import("./types").ASREvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                }) => {
                                    endpoint: string;
                                    key: string;
                                    projectName: string;
                                    deploymentName: string;
                                    query: string;
                                };
                                readonly onDone: readonly [{
                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    readonly target: "#asr.Ready";
                                    readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                }, {
                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    readonly target: "#asr.Ready";
                                }];
                                readonly onError: {
                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    readonly target: "#asr.Ready";
                                };
                            };
                        };
                    };
                };
                readonly Paused: {
                    readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                    readonly on: {
                        readonly CONTROL: {
                            readonly target: "Recognising";
                        };
                    };
                };
                readonly GetToken: {
                    readonly invoke: {
                        readonly id: "getAuthorizationToken";
                        readonly input: ({ context }: {
                            context: any;
                        }) => {
                            credentials: any;
                        };
                        readonly src: "getToken";
                        readonly onDone: {
                            readonly target: "Ponyfill";
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>];
                        };
                        readonly onError: {
                            readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                            readonly target: "Fail";
                        };
                    };
                };
                readonly Ponyfill: {
                    readonly invoke: {
                        readonly id: "ponyASR";
                        readonly src: "ponyfill";
                        readonly input: ({ context }: {
                            context: import("./types").ASRContext;
                            event: import("./types").ASREvent;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            azureRegion: string;
                            audioContext: AudioContext;
                            azureAuthorizationToken: string;
                            locale: string;
                            speechRecognitionEndpointId: string;
                        };
                    };
                };
            };
        }>;
        id: string;
    };
}>, import("xstate").Values<{
    spawnTTS: {
        type: "spawnTTS";
        params: {};
    };
    spawnASR: {
        type: "spawnASR";
        params: {};
    };
}>, never, never, "Stopped" | {
    Active?: Required<{
        AsrTtsSpawner?: "Idle" | "CreateAudioContext" | "Spawn";
        AsrTtsManager?: "Fail" | "Stopped" | "Initialize" | "PreReady" | {
            Ready?: "Idle" | "WaitForRecogniser" | {
                Speaking?: "Paused" | "Proceed";
                Recognising?: "Paused" | "Proceed";
            };
        };
    }>;
}, string, Settings, {}, import("xstate").EventObject, import("xstate").MetaObject, {
    readonly context: ({ input }: {
        spawn: {
            <TSrc_2 extends "audioContext" | "tts" | "asr">(logic: TSrc_2, ...[options]: ({
                src: "audioContext";
                logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                id: string;
            } extends infer T_16 ? T_16 extends {
                src: "audioContext";
                logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                id: string;
            } ? T_16 extends {
                src: TSrc_2;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_16["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_16["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_16 in import("xstate").RequiredActorOptions<T_16>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_16>>> : never : never : never) | ({
                src: "tts";
                logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    createEventsFromStream: {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    start: {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                        id: string;
                    };
                }>, import("xstate").Values<{
                    ttsStop: {
                        type: "ttsStop";
                        params: unknown;
                    };
                    addFiller: {
                        type: "addFiller";
                        params: {};
                    };
                    assignCurrentVoice: {
                        type: "assignCurrentVoice";
                        params: {};
                    };
                    sendParentCurrentPersona: {
                        type: "sendParentCurrentPersona";
                        params: {};
                    };
                }>, import("xstate").Values<{
                    bufferContainsUtterancePartReadyToBeSpoken: {
                        type: "bufferContainsUtterancePartReadyToBeSpoken";
                        params: unknown;
                    };
                    bufferIsNonEmpty: {
                        type: "bufferIsNonEmpty";
                        params: unknown;
                    };
                }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
                    Ready?: "Idle" | {
                        BufferedSpeaker?: Required<{
                            Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                            Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                                Speak?: "Go" | "Paused";
                            };
                        }>;
                        Speaking?: "Go" | "Paused";
                    };
                }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "tts";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_17 ? T_17 extends {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } ? T_17 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_17["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_17["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_17 in import("xstate").RequiredActorOptions<T_17>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_17>>> : never : never : never) | ({
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_18 ? T_18 extends {
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                id: string;
                            } ? T_18 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_18["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_18["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_18 in import("xstate").RequiredActorOptions<T_18>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_18>>> : never : never : never) | ({
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_19 ? T_19 extends {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_19 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_19["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_19["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_19 in import("xstate").RequiredActorOptions<T_19>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_19>>> : never : never : never) | ({
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_20 ? T_20 extends {
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                id: string;
                            } ? T_20 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_20["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_20["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_20 in import("xstate").RequiredActorOptions<T_20>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_20>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc>["logic"]>;
                            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic>;
                        };
                        input: import("./types").TTSInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                    }) => {
                        ttsDefaultVoice: string;
                        ttsLexicon: string;
                        audioContext: AudioContext;
                        azureCredentials: string | import("./types").AzureSpeechCredentials;
                        azureRegion: string;
                        buffer: string;
                    };
                    readonly initial: "GetToken";
                    readonly on: {
                        readonly READY: {
                            readonly target: ".Ready";
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "READY";
                                value: {
                                    wsaTTS: SpeechSynthesis;
                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                };
                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "READY";
                                value: {
                                    wsaTTS: SpeechSynthesis;
                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                };
                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                        };
                        readonly ERROR: {
                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "ERROR";
                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                        };
                    };
                    readonly states: {
                        readonly Ready: {
                            readonly initial: "Idle";
                            readonly states: {
                                readonly Idle: {
                                    readonly on: {
                                        readonly SPEAK: readonly [{
                                            readonly target: "BufferedSpeaker";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: import("./types").Agenda;
                                            }>) => boolean;
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: import("./types").Agenda;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        }, {
                                            readonly target: "Speaking";
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: import("./types").Agenda;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        }];
                                    };
                                };
                                readonly BufferedSpeaker: {
                                    readonly type: "parallel";
                                    readonly invoke: {
                                        readonly id: "createEventsFromStream";
                                        readonly src: "createEventsFromStream";
                                        readonly input: ({ context }: {
                                            context: import("./types").TTSContext;
                                            event: import("./types").TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                        }) => import("./types").Agenda;
                                    };
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "Idle";
                                        };
                                        readonly SPEAK_COMPLETE: readonly [{
                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, undefined, any>;
                                            readonly target: "Idle";
                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                        }];
                                    };
                                    readonly states: {
                                        readonly Buffer: {
                                            readonly initial: "BufferIdle";
                                            readonly on: {
                                                readonly STREAMING_SET_VOICE: {
                                                    readonly actions: "assignCurrentVoice";
                                                };
                                                readonly STREAMING_SET_PERSONA: {
                                                    readonly actions: "sendParentCurrentPersona";
                                                };
                                            };
                                            readonly states: {
                                                readonly BufferIdle: {
                                                    readonly id: "BufferIdle";
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly on: {
                                                        readonly STREAMING_CHUNK: {
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                type: "STREAMING_CHUNK";
                                                                value: string;
                                                            }, import("./types").TTSEvent>) => void];
                                                            readonly target: "Buffering";
                                                        };
                                                    };
                                                };
                                                readonly Buffering: {
                                                    readonly id: "Buffering";
                                                    readonly on: {
                                                        readonly STREAMING_CHUNK: readonly [{
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                type: "STREAMING_CHUNK";
                                                                value: string;
                                                            }, import("./types").TTSEvent>) => void];
                                                            readonly target: "Buffering";
                                                            readonly reenter: true;
                                                        }];
                                                        readonly STREAMING_DONE: readonly [{
                                                            readonly target: "BufferingDone";
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                type: "STREAMING_DONE";
                                                            }, import("./types").TTSEvent>) => void];
                                                        }];
                                                    };
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        getToken: {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                };
                                                readonly BufferingDone: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly id: "BufferingDone";
                                                };
                                            };
                                        };
                                        readonly Speaker: {
                                            readonly initial: "SpeakingIdle";
                                            readonly states: {
                                                readonly SpeakingIdle: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly always: readonly [{
                                                        readonly target: "Speak";
                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                    }, {
                                                        readonly target: "PrepareSpeech";
                                                        readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    }];
                                                    readonly after: {
                                                        readonly FILLER_DELAY: {
                                                            readonly target: "SpeakingIdle";
                                                            readonly reenter: true;
                                                            readonly actions: "addFiller";
                                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                        };
                                                    };
                                                };
                                                readonly PrepareSpeech: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        getToken: {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                    readonly always: readonly [{
                                                        readonly target: "Speak";
                                                    }];
                                                };
                                                readonly Speak: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly initial: "Go";
                                                    readonly on: {
                                                        readonly TTS_STARTED: {
                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                type: "TTS_STARTED";
                                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                        };
                                                        readonly SPEAK_COMPLETE: readonly [{
                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                type: "SPEAK_COMPLETE";
                                                            }, undefined, any>;
                                                            readonly target: "SpeakingIdle";
                                                        }, {
                                                            readonly guard: "bufferIsNonEmpty";
                                                            readonly target: "SpeakingIdle";
                                                        }];
                                                    };
                                                    readonly states: {
                                                        readonly Go: {
                                                            readonly invoke: {
                                                                readonly src: "start";
                                                                readonly input: ({ context }: {
                                                                    context: import("./types").TTSContext;
                                                                    event: import("./types").TTSEvent;
                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                }) => {
                                                                    wsaTTS: SpeechSynthesis;
                                                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                    ttsLexicon: string;
                                                                    voice: string;
                                                                    utterance: string;
                                                                };
                                                            };
                                                            readonly on: {
                                                                readonly CONTROL: "Paused";
                                                            };
                                                            readonly exit: "ttsStop";
                                                        };
                                                        readonly Paused: {
                                                            readonly on: {
                                                                readonly CONTROL: "Go";
                                                            };
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                                readonly Speaking: {
                                    readonly initial: "Go";
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "Idle";
                                        };
                                        readonly TTS_STARTED: {
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "TTS_STARTED";
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                        };
                                        readonly SPEAK_COMPLETE: {
                                            readonly target: "Idle";
                                        };
                                    };
                                    readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                    readonly states: {
                                        readonly Go: {
                                            readonly invoke: {
                                                readonly src: "start";
                                                readonly input: ({ context }: {
                                                    context: import("./types").TTSContext;
                                                    event: import("./types").TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                    ttsLexicon: string;
                                                    voice: string;
                                                    utterance: string;
                                                };
                                            };
                                            readonly on: {
                                                readonly CONTROL: "Paused";
                                            };
                                            readonly exit: "ttsStop";
                                        };
                                        readonly Paused: {
                                            readonly on: {
                                                readonly CONTROL: "Go";
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        readonly Fail: {};
                        readonly GetToken: {
                            readonly invoke: {
                                readonly id: "getAuthorizationToken";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    credentials: any;
                                };
                                readonly src: "getToken";
                                readonly onDone: {
                                    readonly target: "Ponyfill";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly onError: {
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                                    readonly target: "Fail";
                                };
                            };
                        };
                        readonly Ponyfill: {
                            readonly invoke: {
                                readonly id: "ponyTTS";
                                readonly src: "ponyfill";
                                readonly input: ({ context }: {
                                    context: import("./types").TTSContext;
                                    event: import("./types").TTSEvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                }) => {
                                    audioContext: AudioContext;
                                    azureAuthorizationToken: string;
                                    azureRegion: string;
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } extends infer T_21 ? T_21 extends {
                src: "tts";
                logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    createEventsFromStream: {
                        src: "createEventsFromStream";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    start: {
                        src: "start";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                        id: string;
                    };
                }>, import("xstate").Values<{
                    ttsStop: {
                        type: "ttsStop";
                        params: unknown;
                    };
                    addFiller: {
                        type: "addFiller";
                        params: {};
                    };
                    assignCurrentVoice: {
                        type: "assignCurrentVoice";
                        params: {};
                    };
                    sendParentCurrentPersona: {
                        type: "sendParentCurrentPersona";
                        params: {};
                    };
                }>, import("xstate").Values<{
                    bufferContainsUtterancePartReadyToBeSpoken: {
                        type: "bufferContainsUtterancePartReadyToBeSpoken";
                        params: unknown;
                    };
                    bufferIsNonEmpty: {
                        type: "bufferIsNonEmpty";
                        params: unknown;
                    };
                }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
                    Ready?: "Idle" | {
                        BufferedSpeaker?: Required<{
                            Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                            Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                                Speak?: "Go" | "Paused";
                            };
                        }>;
                        Speaking?: "Go" | "Paused";
                    };
                }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "tts";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_22 ? T_22 extends {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } ? T_22 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_22["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_22["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_22 in import("xstate").RequiredActorOptions<T_22>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_22>>> : never : never : never) | ({
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_23 ? T_23 extends {
                                src: "createEventsFromStream";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                id: string;
                            } ? T_23 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_23["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_23["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_23 in import("xstate").RequiredActorOptions<T_23>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_23>>> : never : never : never) | ({
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_24 ? T_24 extends {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_24 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_24["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_24["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_24 in import("xstate").RequiredActorOptions<T_24>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_24>>> : never : never : never) | ({
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_25 ? T_25 extends {
                                src: "start";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                id: string;
                            } ? T_25 extends {
                                src: TSrc;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_25["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_25["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_25 in import("xstate").RequiredActorOptions<T_25>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_25>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc>["logic"]>;
                            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic>;
                        };
                        input: import("./types").TTSInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                    }) => {
                        ttsDefaultVoice: string;
                        ttsLexicon: string;
                        audioContext: AudioContext;
                        azureCredentials: string | import("./types").AzureSpeechCredentials;
                        azureRegion: string;
                        buffer: string;
                    };
                    readonly initial: "GetToken";
                    readonly on: {
                        readonly READY: {
                            readonly target: ".Ready";
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "READY";
                                value: {
                                    wsaTTS: SpeechSynthesis;
                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                };
                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "READY";
                                value: {
                                    wsaTTS: SpeechSynthesis;
                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                };
                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                        };
                        readonly ERROR: {
                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                type: "ERROR";
                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                        };
                    };
                    readonly states: {
                        readonly Ready: {
                            readonly initial: "Idle";
                            readonly states: {
                                readonly Idle: {
                                    readonly on: {
                                        readonly SPEAK: readonly [{
                                            readonly target: "BufferedSpeaker";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: import("./types").Agenda;
                                            }>) => boolean;
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: import("./types").Agenda;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        }, {
                                            readonly target: "Speaking";
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK";
                                                value: import("./types").Agenda;
                                            }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>;
                                        }];
                                    };
                                };
                                readonly BufferedSpeaker: {
                                    readonly type: "parallel";
                                    readonly invoke: {
                                        readonly id: "createEventsFromStream";
                                        readonly src: "createEventsFromStream";
                                        readonly input: ({ context }: {
                                            context: import("./types").TTSContext;
                                            event: import("./types").TTSEvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                        }) => import("./types").Agenda;
                                    };
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "Idle";
                                        };
                                        readonly SPEAK_COMPLETE: readonly [{
                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, undefined, any>;
                                            readonly target: "Idle";
                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                        }];
                                    };
                                    readonly states: {
                                        readonly Buffer: {
                                            readonly initial: "BufferIdle";
                                            readonly on: {
                                                readonly STREAMING_SET_VOICE: {
                                                    readonly actions: "assignCurrentVoice";
                                                };
                                                readonly STREAMING_SET_PERSONA: {
                                                    readonly actions: "sendParentCurrentPersona";
                                                };
                                            };
                                            readonly states: {
                                                readonly BufferIdle: {
                                                    readonly id: "BufferIdle";
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly on: {
                                                        readonly STREAMING_CHUNK: {
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                type: "STREAMING_CHUNK";
                                                                value: string;
                                                            }, import("./types").TTSEvent>) => void];
                                                            readonly target: "Buffering";
                                                        };
                                                    };
                                                };
                                                readonly Buffering: {
                                                    readonly id: "Buffering";
                                                    readonly on: {
                                                        readonly STREAMING_CHUNK: readonly [{
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                type: "STREAMING_CHUNK";
                                                                value: string;
                                                            }, import("./types").TTSEvent>) => void];
                                                            readonly target: "Buffering";
                                                            readonly reenter: true;
                                                        }];
                                                        readonly STREAMING_DONE: readonly [{
                                                            readonly target: "BufferingDone";
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                type: "STREAMING_DONE";
                                                            }, import("./types").TTSEvent>) => void];
                                                        }];
                                                    };
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        getToken: {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                };
                                                readonly BufferingDone: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly id: "BufferingDone";
                                                };
                                            };
                                        };
                                        readonly Speaker: {
                                            readonly initial: "SpeakingIdle";
                                            readonly states: {
                                                readonly SpeakingIdle: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly always: readonly [{
                                                        readonly target: "Speak";
                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                    }, {
                                                        readonly target: "PrepareSpeech";
                                                        readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    }];
                                                    readonly after: {
                                                        readonly FILLER_DELAY: {
                                                            readonly target: "SpeakingIdle";
                                                            readonly reenter: true;
                                                            readonly actions: "addFiller";
                                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                        };
                                                    };
                                                };
                                                readonly PrepareSpeech: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                        getToken: {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        createEventsFromStream: {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        ponyfill: {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                        start: {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        };
                                                    }>, never, never, never, never>];
                                                    readonly always: readonly [{
                                                        readonly target: "Speak";
                                                    }];
                                                };
                                                readonly Speak: {
                                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                    readonly initial: "Go";
                                                    readonly on: {
                                                        readonly TTS_STARTED: {
                                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                type: "TTS_STARTED";
                                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                        };
                                                        readonly SPEAK_COMPLETE: readonly [{
                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                type: "SPEAK_COMPLETE";
                                                            }, undefined, any>;
                                                            readonly target: "SpeakingIdle";
                                                        }, {
                                                            readonly guard: "bufferIsNonEmpty";
                                                            readonly target: "SpeakingIdle";
                                                        }];
                                                    };
                                                    readonly states: {
                                                        readonly Go: {
                                                            readonly invoke: {
                                                                readonly src: "start";
                                                                readonly input: ({ context }: {
                                                                    context: import("./types").TTSContext;
                                                                    event: import("./types").TTSEvent;
                                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                }) => {
                                                                    wsaTTS: SpeechSynthesis;
                                                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                    ttsLexicon: string;
                                                                    voice: string;
                                                                    utterance: string;
                                                                };
                                                            };
                                                            readonly on: {
                                                                readonly CONTROL: "Paused";
                                                            };
                                                            readonly exit: "ttsStop";
                                                        };
                                                        readonly Paused: {
                                                            readonly on: {
                                                                readonly CONTROL: "Go";
                                                            };
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                };
                                readonly Speaking: {
                                    readonly initial: "Go";
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "Idle";
                                        };
                                        readonly TTS_STARTED: {
                                            readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                type: "TTS_STARTED";
                                            }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                        };
                                        readonly SPEAK_COMPLETE: {
                                            readonly target: "Idle";
                                        };
                                    };
                                    readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                    readonly states: {
                                        readonly Go: {
                                            readonly invoke: {
                                                readonly src: "start";
                                                readonly input: ({ context }: {
                                                    context: import("./types").TTSContext;
                                                    event: import("./types").TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                    ttsLexicon: string;
                                                    voice: string;
                                                    utterance: string;
                                                };
                                            };
                                            readonly on: {
                                                readonly CONTROL: "Paused";
                                            };
                                            readonly exit: "ttsStop";
                                        };
                                        readonly Paused: {
                                            readonly on: {
                                                readonly CONTROL: "Go";
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        readonly Fail: {};
                        readonly GetToken: {
                            readonly invoke: {
                                readonly id: "getAuthorizationToken";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    credentials: any;
                                };
                                readonly src: "getToken";
                                readonly onDone: {
                                    readonly target: "Ponyfill";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly onError: {
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                                    readonly target: "Fail";
                                };
                            };
                        };
                        readonly Ponyfill: {
                            readonly invoke: {
                                readonly id: "ponyTTS";
                                readonly src: "ponyfill";
                                readonly input: ({ context }: {
                                    context: import("./types").TTSContext;
                                    event: import("./types").TTSEvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                }) => {
                                    audioContext: AudioContext;
                                    azureAuthorizationToken: string;
                                    azureRegion: string;
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } ? T_21 extends {
                src: TSrc_2;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_21["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_21["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_21 in import("xstate").RequiredActorOptions<T_21>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_21>>> : never : never : never) | ({
                src: "asr";
                logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                    }, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    recStart: {
                        src: "recStart";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, {
                    type: "recStop";
                    params: unknown;
                }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
                    Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
                }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "asr";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_26 ? T_26 extends {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } ? T_26 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_26["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_26["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_26 in import("xstate").RequiredActorOptions<T_26>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_26>>> : never : never : never) | ({
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_27 ? T_27 extends {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_27 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_27["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_27["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_27 in import("xstate").RequiredActorOptions<T_27>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_27>>> : never : never : never) | ({
                                src: "recStart";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_28 ? T_28 extends {
                                src: "recStart";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                id: string;
                            } ? T_28 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_28["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_28["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_28 in import("xstate").RequiredActorOptions<T_28>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_28>>> : never : never : never) | ({
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_29 ? T_29 extends {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_29 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_29["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_29["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_29 in import("xstate").RequiredActorOptions<T_29>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_29>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc_1>["logic"]>;
                            <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic_1>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic_1>;
                        };
                        input: import("./types").ASRInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                    }) => {
                        asrDefaultCompleteTimeout: number;
                        asrDefaultNoInputTimeout: number;
                        locale: string;
                        audioContext: AudioContext;
                        azureCredentials: string | import("./types").AzureSpeechCredentials;
                        azureRegion: string;
                        azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                        speechRecognitionEndpointId: string;
                    };
                    readonly initial: "GetToken";
                    readonly on: {
                        readonly READY: {
                            readonly target: ".Ready";
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "READY";
                                value: {
                                    wsaASR: import("./types").MySpeechRecognition;
                                    wsaGrammarList: import("./types").MySpeechGrammarList;
                                };
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "READY";
                                value: {
                                    wsaASR: import("./types").MySpeechRecognition;
                                    wsaGrammarList: import("./types").MySpeechGrammarList;
                                };
                            }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                        };
                    };
                    readonly states: {
                        readonly Fail: {};
                        readonly Ready: {
                            readonly on: {
                                readonly START: {
                                    readonly target: "Recognising";
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "START";
                                        value?: import("./types").RecogniseParameters;
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        recStart: {
                                            src: "recStart";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                };
                            };
                        };
                        readonly Recognising: {
                            readonly initial: "WaitForRecogniser";
                            readonly invoke: {
                                readonly id: "recStart";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    wsaASR: any;
                                    wsaGrammarList: any;
                                    locale: any;
                                    phrases: any;
                                };
                                readonly src: "recStart";
                            };
                            readonly exit: "recStop";
                            readonly on: {
                                readonly RESULT: {
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: import("./types").Hypothesis[];
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        recStart: {
                                            src: "recStart";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: import("./types").Hypothesis[];
                                    }, undefined, import("./types").ASREvent>];
                                    readonly target: ".Match";
                                };
                                readonly RECOGNISED: readonly [{
                                    readonly target: ".NLURequest";
                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                                        type: "RECOGNISED";
                                    }>) => boolean;
                                }, {
                                    readonly target: "Ready";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "RECOGNISED";
                                    }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                }];
                                readonly CONTROL: {
                                    readonly target: "Paused";
                                };
                                readonly STOP: {
                                    readonly target: "Ready";
                                };
                                readonly NOINPUT: {
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "NOINPUT";
                                    }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                    readonly target: "Ready";
                                };
                            };
                            readonly states: {
                                readonly WaitForRecogniser: {
                                    readonly on: {
                                        readonly STARTED: {
                                            readonly target: "NoInput";
                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "STARTED";
                                                value: {
                                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                                };
                                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                recStart: {
                                                    src: "recStart";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "STARTED";
                                                value: {
                                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                                };
                                            }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                        };
                                    };
                                };
                                readonly NoInput: {
                                    readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    readonly on: {
                                        readonly STARTSPEECH: {
                                            readonly target: "InProgress";
                                            readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                type: "STARTSPEECH";
                                            }, undefined, import("./types").ASREvent>;
                                        };
                                    };
                                    readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                                };
                                readonly InProgress: {
                                    readonly entry: () => void;
                                };
                                readonly Match: {
                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                };
                                readonly NLURequest: {
                                    readonly invoke: {
                                        readonly src: "nluPromise";
                                        readonly input: ({ context }: {
                                            context: import("./types").ASRContext;
                                            event: import("./types").ASREvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            endpoint: string;
                                            key: string;
                                            projectName: string;
                                            deploymentName: string;
                                            query: string;
                                        };
                                        readonly onDone: readonly [{
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            readonly target: "#asr.Ready";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                        }, {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            readonly target: "#asr.Ready";
                                        }];
                                        readonly onError: {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            readonly target: "#asr.Ready";
                                        };
                                    };
                                };
                            };
                        };
                        readonly Paused: {
                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                            readonly on: {
                                readonly CONTROL: {
                                    readonly target: "Recognising";
                                };
                            };
                        };
                        readonly GetToken: {
                            readonly invoke: {
                                readonly id: "getAuthorizationToken";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    credentials: any;
                                };
                                readonly src: "getToken";
                                readonly onDone: {
                                    readonly target: "Ponyfill";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        recStart: {
                                            src: "recStart";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly onError: {
                                    readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                                    readonly target: "Fail";
                                };
                            };
                        };
                        readonly Ponyfill: {
                            readonly invoke: {
                                readonly id: "ponyASR";
                                readonly src: "ponyfill";
                                readonly input: ({ context }: {
                                    context: import("./types").ASRContext;
                                    event: import("./types").ASREvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                }) => {
                                    azureRegion: string;
                                    audioContext: AudioContext;
                                    azureAuthorizationToken: string;
                                    locale: string;
                                    speechRecognitionEndpointId: string;
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } extends infer T_30 ? T_30 extends {
                src: "asr";
                logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                        query: string;
                    }, import("xstate").EventObject>>;
                }, import("xstate").Values<{
                    getToken: {
                        src: "getToken";
                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                        id: string;
                    };
                    ponyfill: {
                        src: "ponyfill";
                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                        id: string;
                    };
                    recStart: {
                        src: "recStart";
                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                        id: string;
                    };
                    nluPromise: {
                        src: "nluPromise";
                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>;
                        id: string;
                    };
                }>, {
                    type: "recStop";
                    params: unknown;
                }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
                    Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
                }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                    readonly id: "asr";
                    readonly context: ({ input }: {
                        spawn: {
                            <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_31 ? T_31 extends {
                                src: "getToken";
                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                id: string;
                            } ? T_31 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_31["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_31["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_31 in import("xstate").RequiredActorOptions<T_31>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_31>>> : never : never : never) | ({
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_32 ? T_32 extends {
                                src: "ponyfill";
                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                id: string;
                            } ? T_32 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_32["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_32["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_32 in import("xstate").RequiredActorOptions<T_32>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_32>>> : never : never : never) | ({
                                src: "recStart";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_33 ? T_33 extends {
                                src: "recStart";
                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                id: string;
                            } ? T_33 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_33["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_33["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_33 in import("xstate").RequiredActorOptions<T_33>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_33>>> : never : never : never) | ({
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } extends infer T_34 ? T_34 extends {
                                src: "nluPromise";
                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                    query: string;
                                }, import("xstate").EventObject>;
                                id: string;
                            } ? T_34 extends {
                                src: TSrc_1;
                            } ? import("xstate").ConditionalRequired<[options?: {
                                id?: T_34["id"];
                                systemId?: string;
                                input?: import("xstate").InputFrom<T_34["logic"]>;
                                syncSnapshot?: boolean;
                            } & { [K_34 in import("xstate").RequiredActorOptions<T_34>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_34>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, "src", TSrc_1>["logic"]>;
                            <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                                id?: never;
                                systemId?: string;
                                input?: import("xstate").InputFrom<TLogic_1>;
                                syncSnapshot?: boolean;
                            }): import("xstate").ActorRefFromLogic<TLogic_1>;
                        };
                        input: import("./types").ASRInit;
                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                    }) => {
                        asrDefaultCompleteTimeout: number;
                        asrDefaultNoInputTimeout: number;
                        locale: string;
                        audioContext: AudioContext;
                        azureCredentials: string | import("./types").AzureSpeechCredentials;
                        azureRegion: string;
                        azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                        speechRecognitionEndpointId: string;
                    };
                    readonly initial: "GetToken";
                    readonly on: {
                        readonly READY: {
                            readonly target: ".Ready";
                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "READY";
                                value: {
                                    wsaASR: import("./types").MySpeechRecognition;
                                    wsaGrammarList: import("./types").MySpeechGrammarList;
                                };
                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                type: "READY";
                                value: {
                                    wsaASR: import("./types").MySpeechRecognition;
                                    wsaGrammarList: import("./types").MySpeechGrammarList;
                                };
                            }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                        };
                    };
                    readonly states: {
                        readonly Fail: {};
                        readonly Ready: {
                            readonly on: {
                                readonly START: {
                                    readonly target: "Recognising";
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "START";
                                        value?: import("./types").RecogniseParameters;
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        recStart: {
                                            src: "recStart";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                };
                            };
                        };
                        readonly Recognising: {
                            readonly initial: "WaitForRecogniser";
                            readonly invoke: {
                                readonly id: "recStart";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    wsaASR: any;
                                    wsaGrammarList: any;
                                    locale: any;
                                    phrases: any;
                                };
                                readonly src: "recStart";
                            };
                            readonly exit: "recStop";
                            readonly on: {
                                readonly RESULT: {
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: import("./types").Hypothesis[];
                                    }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        recStart: {
                                            src: "recStart";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                        type: "RESULT";
                                        value: import("./types").Hypothesis[];
                                    }, undefined, import("./types").ASREvent>];
                                    readonly target: ".Match";
                                };
                                readonly RECOGNISED: readonly [{
                                    readonly target: ".NLURequest";
                                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                                        type: "RECOGNISED";
                                    }>) => boolean;
                                }, {
                                    readonly target: "Ready";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "RECOGNISED";
                                    }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                }];
                                readonly CONTROL: {
                                    readonly target: "Paused";
                                };
                                readonly STOP: {
                                    readonly target: "Ready";
                                };
                                readonly NOINPUT: {
                                    readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                        type: "NOINPUT";
                                    }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                    readonly target: "Ready";
                                };
                            };
                            readonly states: {
                                readonly WaitForRecogniser: {
                                    readonly on: {
                                        readonly STARTED: {
                                            readonly target: "NoInput";
                                            readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "STARTED";
                                                value: {
                                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                                };
                                            }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                recStart: {
                                                    src: "recStart";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                type: "STARTED";
                                                value: {
                                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                                };
                                            }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                        };
                                    };
                                };
                                readonly NoInput: {
                                    readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    readonly on: {
                                        readonly STARTSPEECH: {
                                            readonly target: "InProgress";
                                            readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                type: "STARTSPEECH";
                                            }, undefined, import("./types").ASREvent>;
                                        };
                                    };
                                    readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                                };
                                readonly InProgress: {
                                    readonly entry: () => void;
                                };
                                readonly Match: {
                                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                };
                                readonly NLURequest: {
                                    readonly invoke: {
                                        readonly src: "nluPromise";
                                        readonly input: ({ context }: {
                                            context: import("./types").ASRContext;
                                            event: import("./types").ASREvent;
                                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                        }) => {
                                            endpoint: string;
                                            key: string;
                                            projectName: string;
                                            deploymentName: string;
                                            query: string;
                                        };
                                        readonly onDone: readonly [{
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            readonly target: "#asr.Ready";
                                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                        }, {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            readonly target: "#asr.Ready";
                                        }];
                                        readonly onError: {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            readonly target: "#asr.Ready";
                                        };
                                    };
                                };
                            };
                        };
                        readonly Paused: {
                            readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                            readonly on: {
                                readonly CONTROL: {
                                    readonly target: "Recognising";
                                };
                            };
                        };
                        readonly GetToken: {
                            readonly invoke: {
                                readonly id: "getAuthorizationToken";
                                readonly input: ({ context }: {
                                    context: any;
                                }) => {
                                    credentials: any;
                                };
                                readonly src: "getToken";
                                readonly onDone: {
                                    readonly target: "Ponyfill";
                                    readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        recStart: {
                                            src: "recStart";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        nluPromise: {
                                            src: "nluPromise";
                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                query: string;
                                            }, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly onError: {
                                    readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                                    readonly target: "Fail";
                                };
                            };
                        };
                        readonly Ponyfill: {
                            readonly invoke: {
                                readonly id: "ponyASR";
                                readonly src: "ponyfill";
                                readonly input: ({ context }: {
                                    context: import("./types").ASRContext;
                                    event: import("./types").ASREvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                }) => {
                                    azureRegion: string;
                                    audioContext: AudioContext;
                                    azureAuthorizationToken: string;
                                    locale: string;
                                    speechRecognitionEndpointId: string;
                                };
                            };
                        };
                    };
                }>;
                id: string;
            } ? T_30 extends {
                src: TSrc_2;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_30["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_30["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_30 in import("xstate").RequiredActorOptions<T_30>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_30>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                audioContext: {
                    src: "audioContext";
                    logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                    id: string;
                };
                tts: {
                    src: "tts";
                    logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, import("xstate").Values<{
                        ttsStop: {
                            type: "ttsStop";
                            params: unknown;
                        };
                        addFiller: {
                            type: "addFiller";
                            params: {};
                        };
                        assignCurrentVoice: {
                            type: "assignCurrentVoice";
                            params: {};
                        };
                        sendParentCurrentPersona: {
                            type: "sendParentCurrentPersona";
                            params: {};
                        };
                    }>, import("xstate").Values<{
                        bufferContainsUtterancePartReadyToBeSpoken: {
                            type: "bufferContainsUtterancePartReadyToBeSpoken";
                            params: unknown;
                        };
                        bufferIsNonEmpty: {
                            type: "bufferIsNonEmpty";
                            params: unknown;
                        };
                    }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
                        Ready?: "Idle" | {
                            BufferedSpeaker?: Required<{
                                Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                                Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                                    Speak?: "Go" | "Paused";
                                };
                            }>;
                            Speaking?: "Go" | "Paused";
                        };
                    }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "tts";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_35 ? T_35 extends {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } ? T_35 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_35["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_35["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_35 in import("xstate").RequiredActorOptions<T_35>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_35>>> : never : never : never) | ({
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_36 ? T_36 extends {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                } ? T_36 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_36["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_36["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_36 in import("xstate").RequiredActorOptions<T_36>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_36>>> : never : never : never) | ({
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_37 ? T_37 extends {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T_37 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_37["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_37["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_37 in import("xstate").RequiredActorOptions<T_37>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_37>>> : never : never : never) | ({
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_38 ? T_38 extends {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                } ? T_38 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_38["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_38["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_38 in import("xstate").RequiredActorOptions<T_38>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_38>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc>["logic"]>;
                                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic>;
                            };
                            input: import("./types").TTSInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                        }) => {
                            ttsDefaultVoice: string;
                            ttsLexicon: string;
                            audioContext: AudioContext;
                            azureCredentials: string | import("./types").AzureSpeechCredentials;
                            azureRegion: string;
                            buffer: string;
                        };
                        readonly initial: "GetToken";
                        readonly on: {
                            readonly READY: {
                                readonly target: ".Ready";
                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "READY";
                                    value: {
                                        wsaTTS: SpeechSynthesis;
                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                    };
                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "READY";
                                    value: {
                                        wsaTTS: SpeechSynthesis;
                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                    };
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                            };
                            readonly ERROR: {
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "ERROR";
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                            };
                        };
                        readonly states: {
                            readonly Ready: {
                                readonly initial: "Idle";
                                readonly states: {
                                    readonly Idle: {
                                        readonly on: {
                                            readonly SPEAK: readonly [{
                                                readonly target: "BufferedSpeaker";
                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                    type: "SPEAK";
                                                    value: import("./types").Agenda;
                                                }>) => boolean;
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "SPEAK";
                                                    value: import("./types").Agenda;
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                            }, {
                                                readonly target: "Speaking";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "SPEAK";
                                                    value: import("./types").Agenda;
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                            }];
                                        };
                                    };
                                    readonly BufferedSpeaker: {
                                        readonly type: "parallel";
                                        readonly invoke: {
                                            readonly id: "createEventsFromStream";
                                            readonly src: "createEventsFromStream";
                                            readonly input: ({ context }: {
                                                context: import("./types").TTSContext;
                                                event: import("./types").TTSEvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                            }) => import("./types").Agenda;
                                        };
                                        readonly on: {
                                            readonly STOP: {
                                                readonly target: "Idle";
                                            };
                                            readonly SPEAK_COMPLETE: readonly [{
                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                    type: "SPEAK_COMPLETE";
                                                }, undefined, any>;
                                                readonly target: "Idle";
                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "SPEAK_COMPLETE";
                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                            }];
                                        };
                                        readonly states: {
                                            readonly Buffer: {
                                                readonly initial: "BufferIdle";
                                                readonly on: {
                                                    readonly STREAMING_SET_VOICE: {
                                                        readonly actions: "assignCurrentVoice";
                                                    };
                                                    readonly STREAMING_SET_PERSONA: {
                                                        readonly actions: "sendParentCurrentPersona";
                                                    };
                                                };
                                                readonly states: {
                                                    readonly BufferIdle: {
                                                        readonly id: "BufferIdle";
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly on: {
                                                            readonly STREAMING_CHUNK: {
                                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                    type: "STREAMING_CHUNK";
                                                                    value: string;
                                                                }, import("./types").TTSEvent>) => void];
                                                                readonly target: "Buffering";
                                                            };
                                                        };
                                                    };
                                                    readonly Buffering: {
                                                        readonly id: "Buffering";
                                                        readonly on: {
                                                            readonly STREAMING_CHUNK: readonly [{
                                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                    type: "STREAMING_CHUNK";
                                                                    value: string;
                                                                }, import("./types").TTSEvent>) => void];
                                                                readonly target: "Buffering";
                                                                readonly reenter: true;
                                                            }];
                                                            readonly STREAMING_DONE: readonly [{
                                                                readonly target: "BufferingDone";
                                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                    type: "STREAMING_DONE";
                                                                }, import("./types").TTSEvent>) => void];
                                                            }];
                                                        };
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                    };
                                                    readonly BufferingDone: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly id: "BufferingDone";
                                                    };
                                                };
                                            };
                                            readonly Speaker: {
                                                readonly initial: "SpeakingIdle";
                                                readonly states: {
                                                    readonly SpeakingIdle: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly always: readonly [{
                                                            readonly target: "Speak";
                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                getToken: {
                                                                    src: "getToken";
                                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                getToken: {
                                                                    src: "getToken";
                                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>];
                                                        }, {
                                                            readonly target: "PrepareSpeech";
                                                            readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                        }];
                                                        readonly after: {
                                                            readonly FILLER_DELAY: {
                                                                readonly target: "SpeakingIdle";
                                                                readonly reenter: true;
                                                                readonly actions: "addFiller";
                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                            };
                                                        };
                                                    };
                                                    readonly PrepareSpeech: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                        readonly always: readonly [{
                                                            readonly target: "Speak";
                                                        }];
                                                    };
                                                    readonly Speak: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly initial: "Go";
                                                        readonly on: {
                                                            readonly TTS_STARTED: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                    type: "TTS_STARTED";
                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                            };
                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                    type: "SPEAK_COMPLETE";
                                                                }, undefined, any>;
                                                                readonly target: "SpeakingIdle";
                                                            }, {
                                                                readonly guard: "bufferIsNonEmpty";
                                                                readonly target: "SpeakingIdle";
                                                            }];
                                                        };
                                                        readonly states: {
                                                            readonly Go: {
                                                                readonly invoke: {
                                                                    readonly src: "start";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        wsaTTS: SpeechSynthesis;
                                                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                        ttsLexicon: string;
                                                                        voice: string;
                                                                        utterance: string;
                                                                    };
                                                                };
                                                                readonly on: {
                                                                    readonly CONTROL: "Paused";
                                                                };
                                                                readonly exit: "ttsStop";
                                                            };
                                                            readonly Paused: {
                                                                readonly on: {
                                                                    readonly CONTROL: "Go";
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                    readonly Speaking: {
                                        readonly initial: "Go";
                                        readonly on: {
                                            readonly STOP: {
                                                readonly target: "Idle";
                                            };
                                            readonly TTS_STARTED: {
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "TTS_STARTED";
                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                            };
                                            readonly SPEAK_COMPLETE: {
                                                readonly target: "Idle";
                                            };
                                        };
                                        readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                        readonly states: {
                                            readonly Go: {
                                                readonly invoke: {
                                                    readonly src: "start";
                                                    readonly input: ({ context }: {
                                                        context: import("./types").TTSContext;
                                                        event: import("./types").TTSEvent;
                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                    }) => {
                                                        wsaTTS: SpeechSynthesis;
                                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                        ttsLexicon: string;
                                                        voice: string;
                                                        utterance: string;
                                                    };
                                                };
                                                readonly on: {
                                                    readonly CONTROL: "Paused";
                                                };
                                                readonly exit: "ttsStop";
                                            };
                                            readonly Paused: {
                                                readonly on: {
                                                    readonly CONTROL: "Go";
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                            readonly Fail: {};
                            readonly GetToken: {
                                readonly invoke: {
                                    readonly id: "getAuthorizationToken";
                                    readonly input: ({ context }: {
                                        context: any;
                                    }) => {
                                        credentials: any;
                                    };
                                    readonly src: "getToken";
                                    readonly onDone: {
                                        readonly target: "Ponyfill";
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly onError: {
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                                        readonly target: "Fail";
                                    };
                                };
                            };
                            readonly Ponyfill: {
                                readonly invoke: {
                                    readonly id: "ponyTTS";
                                    readonly src: "ponyfill";
                                    readonly input: ({ context }: {
                                        context: import("./types").TTSContext;
                                        event: import("./types").TTSEvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                    }) => {
                                        audioContext: AudioContext;
                                        azureAuthorizationToken: string;
                                        azureRegion: string;
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
                asr: {
                    src: "asr";
                    logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        recStart: {
                            src: "recStart";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, {
                        type: "recStop";
                        params: unknown;
                    }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
                        Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
                    }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "asr";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_39 ? T_39 extends {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } ? T_39 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_39["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_39["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_39 in import("xstate").RequiredActorOptions<T_39>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_39>>> : never : never : never) | ({
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_40 ? T_40 extends {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T_40 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_40["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_40["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_40 in import("xstate").RequiredActorOptions<T_40>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_40>>> : never : never : never) | ({
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_41 ? T_41 extends {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                } ? T_41 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_41["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_41["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_41 in import("xstate").RequiredActorOptions<T_41>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_41>>> : never : never : never) | ({
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_42 ? T_42 extends {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_42 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_42["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_42["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_42 in import("xstate").RequiredActorOptions<T_42>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_42>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    recStart: {
                                        src: "recStart";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc_1>["logic"]>;
                                <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic_1>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic_1>;
                            };
                            input: import("./types").ASRInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            asrDefaultCompleteTimeout: number;
                            asrDefaultNoInputTimeout: number;
                            locale: string;
                            audioContext: AudioContext;
                            azureCredentials: string | import("./types").AzureSpeechCredentials;
                            azureRegion: string;
                            azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                            speechRecognitionEndpointId: string;
                        };
                        readonly initial: "GetToken";
                        readonly on: {
                            readonly READY: {
                                readonly target: ".Ready";
                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "READY";
                                    value: {
                                        wsaASR: import("./types").MySpeechRecognition;
                                        wsaGrammarList: import("./types").MySpeechGrammarList;
                                    };
                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    recStart: {
                                        src: "recStart";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "READY";
                                    value: {
                                        wsaASR: import("./types").MySpeechRecognition;
                                        wsaGrammarList: import("./types").MySpeechGrammarList;
                                    };
                                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                            };
                        };
                        readonly states: {
                            readonly Fail: {};
                            readonly Ready: {
                                readonly on: {
                                    readonly START: {
                                        readonly target: "Recognising";
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "START";
                                            value?: import("./types").RecogniseParameters;
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            recStart: {
                                                src: "recStart";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>;
                                    };
                                };
                            };
                            readonly Recognising: {
                                readonly initial: "WaitForRecogniser";
                                readonly invoke: {
                                    readonly id: "recStart";
                                    readonly input: ({ context }: {
                                        context: any;
                                    }) => {
                                        wsaASR: any;
                                        wsaGrammarList: any;
                                        locale: any;
                                        phrases: any;
                                    };
                                    readonly src: "recStart";
                                };
                                readonly exit: "recStop";
                                readonly on: {
                                    readonly RESULT: {
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: import("./types").Hypothesis[];
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            recStart: {
                                                src: "recStart";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: import("./types").Hypothesis[];
                                        }, undefined, import("./types").ASREvent>];
                                        readonly target: ".Match";
                                    };
                                    readonly RECOGNISED: readonly [{
                                        readonly target: ".NLURequest";
                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                                            type: "RECOGNISED";
                                        }>) => boolean;
                                    }, {
                                        readonly target: "Ready";
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "RECOGNISED";
                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    }];
                                    readonly CONTROL: {
                                        readonly target: "Paused";
                                    };
                                    readonly STOP: {
                                        readonly target: "Ready";
                                    };
                                    readonly NOINPUT: {
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "NOINPUT";
                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                        readonly target: "Ready";
                                    };
                                };
                                readonly states: {
                                    readonly WaitForRecogniser: {
                                        readonly on: {
                                            readonly STARTED: {
                                                readonly target: "NoInput";
                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "STARTED";
                                                    value: {
                                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                                    };
                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    recStart: {
                                                        src: "recStart";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    nluPromise: {
                                                        src: "nluPromise";
                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                            query: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "STARTED";
                                                    value: {
                                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                                    };
                                                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            };
                                        };
                                    };
                                    readonly NoInput: {
                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                        readonly on: {
                                            readonly STARTSPEECH: {
                                                readonly target: "InProgress";
                                                readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                    type: "STARTSPEECH";
                                                }, undefined, import("./types").ASREvent>;
                                            };
                                        };
                                        readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                                    };
                                    readonly InProgress: {
                                        readonly entry: () => void;
                                    };
                                    readonly Match: {
                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    };
                                    readonly NLURequest: {
                                        readonly invoke: {
                                            readonly src: "nluPromise";
                                            readonly input: ({ context }: {
                                                context: import("./types").ASRContext;
                                                event: import("./types").ASREvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                endpoint: string;
                                                key: string;
                                                projectName: string;
                                                deploymentName: string;
                                                query: string;
                                            };
                                            readonly onDone: readonly [{
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                readonly target: "#asr.Ready";
                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                            }, {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                readonly target: "#asr.Ready";
                                            }];
                                            readonly onError: {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                readonly target: "#asr.Ready";
                                            };
                                        };
                                    };
                                };
                            };
                            readonly Paused: {
                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                readonly on: {
                                    readonly CONTROL: {
                                        readonly target: "Recognising";
                                    };
                                };
                            };
                            readonly GetToken: {
                                readonly invoke: {
                                    readonly id: "getAuthorizationToken";
                                    readonly input: ({ context }: {
                                        context: any;
                                    }) => {
                                        credentials: any;
                                    };
                                    readonly src: "getToken";
                                    readonly onDone: {
                                        readonly target: "Ponyfill";
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            recStart: {
                                                src: "recStart";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly onError: {
                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                                        readonly target: "Fail";
                                    };
                                };
                            };
                            readonly Ponyfill: {
                                readonly invoke: {
                                    readonly id: "ponyASR";
                                    readonly src: "ponyfill";
                                    readonly input: ({ context }: {
                                        context: import("./types").ASRContext;
                                        event: import("./types").ASREvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                    }) => {
                                        azureRegion: string;
                                        audioContext: AudioContext;
                                        azureAuthorizationToken: string;
                                        locale: string;
                                        speechRecognitionEndpointId: string;
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
            }>, "src", TSrc_2>["logic"]>;
            <TLogic_2 extends import("xstate").AnyActorLogic>(src: TLogic_2, options?: {
                id?: never;
                systemId?: string;
                input?: import("xstate").InputFrom<TLogic_2>;
                syncSnapshot?: boolean;
            }): import("xstate").ActorRefFromLogic<TLogic_2>;
        };
        input: Settings;
        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<SSContext, SpeechStateEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, SpeechStateEvent, import("xstate").AnyEventObject>;
    }) => {
        settings: Settings;
    };
    readonly id: "speechstate";
    readonly initial: "Active";
    readonly states: {
        readonly Stopped: {
            readonly meta: {
                readonly view: "stopped";
            };
            readonly entry: readonly [import("xstate").StopAction<SSContext, SpeechStateEvent, undefined, SpeechStateEvent>, import("xstate").StopAction<SSContext, SpeechStateEvent, undefined, SpeechStateEvent>, import("xstate").ActionFunction<SSContext, SpeechStateEvent, SpeechStateEvent, undefined, import("xstate").Values<{
                audioContext: {
                    src: "audioContext";
                    logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                    id: string;
                };
                tts: {
                    src: "tts";
                    logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, import("xstate").Values<{
                        ttsStop: {
                            type: "ttsStop";
                            params: unknown;
                        };
                        addFiller: {
                            type: "addFiller";
                            params: {};
                        };
                        assignCurrentVoice: {
                            type: "assignCurrentVoice";
                            params: {};
                        };
                        sendParentCurrentPersona: {
                            type: "sendParentCurrentPersona";
                            params: {};
                        };
                    }>, import("xstate").Values<{
                        bufferContainsUtterancePartReadyToBeSpoken: {
                            type: "bufferContainsUtterancePartReadyToBeSpoken";
                            params: unknown;
                        };
                        bufferIsNonEmpty: {
                            type: "bufferIsNonEmpty";
                            params: unknown;
                        };
                    }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
                        Ready?: "Idle" | {
                            BufferedSpeaker?: Required<{
                                Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                                Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                                    Speak?: "Go" | "Paused";
                                };
                            }>;
                            Speaking?: "Go" | "Paused";
                        };
                    }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "tts";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_43 ? T_43 extends {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } ? T_43 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_43["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_43["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_43 in import("xstate").RequiredActorOptions<T_43>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_43>>> : never : never : never) | ({
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_44 ? T_44 extends {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                    id: string;
                                } ? T_44 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_44["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_44["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_44 in import("xstate").RequiredActorOptions<T_44>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_44>>> : never : never : never) | ({
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_45 ? T_45 extends {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T_45 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_45["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_45["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_45 in import("xstate").RequiredActorOptions<T_45>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_45>>> : never : never : never) | ({
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_46 ? T_46 extends {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                } ? T_46 extends {
                                    src: TSrc;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_46["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_46["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_46 in import("xstate").RequiredActorOptions<T_46>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_46>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc>["logic"]>;
                                <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic>;
                            };
                            input: import("./types").TTSInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                        }) => {
                            ttsDefaultVoice: string;
                            ttsLexicon: string;
                            audioContext: AudioContext;
                            azureCredentials: string | import("./types").AzureSpeechCredentials;
                            azureRegion: string;
                            buffer: string;
                        };
                        readonly initial: "GetToken";
                        readonly on: {
                            readonly READY: {
                                readonly target: ".Ready";
                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "READY";
                                    value: {
                                        wsaTTS: SpeechSynthesis;
                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                    };
                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    createEventsFromStream: {
                                        src: "createEventsFromStream";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    start: {
                                        src: "start";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "READY";
                                    value: {
                                        wsaTTS: SpeechSynthesis;
                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                    };
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                            };
                            readonly ERROR: {
                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                    type: "ERROR";
                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                            };
                        };
                        readonly states: {
                            readonly Ready: {
                                readonly initial: "Idle";
                                readonly states: {
                                    readonly Idle: {
                                        readonly on: {
                                            readonly SPEAK: readonly [{
                                                readonly target: "BufferedSpeaker";
                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                    type: "SPEAK";
                                                    value: import("./types").Agenda;
                                                }>) => boolean;
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "SPEAK";
                                                    value: import("./types").Agenda;
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                            }, {
                                                readonly target: "Speaking";
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "SPEAK";
                                                    value: import("./types").Agenda;
                                                }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    createEventsFromStream: {
                                                        src: "createEventsFromStream";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    start: {
                                                        src: "start";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>;
                                            }];
                                        };
                                    };
                                    readonly BufferedSpeaker: {
                                        readonly type: "parallel";
                                        readonly invoke: {
                                            readonly id: "createEventsFromStream";
                                            readonly src: "createEventsFromStream";
                                            readonly input: ({ context }: {
                                                context: import("./types").TTSContext;
                                                event: import("./types").TTSEvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                            }) => import("./types").Agenda;
                                        };
                                        readonly on: {
                                            readonly STOP: {
                                                readonly target: "Idle";
                                            };
                                            readonly SPEAK_COMPLETE: readonly [{
                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                    type: "SPEAK_COMPLETE";
                                                }, undefined, any>;
                                                readonly target: "Idle";
                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "SPEAK_COMPLETE";
                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                            }];
                                        };
                                        readonly states: {
                                            readonly Buffer: {
                                                readonly initial: "BufferIdle";
                                                readonly on: {
                                                    readonly STREAMING_SET_VOICE: {
                                                        readonly actions: "assignCurrentVoice";
                                                    };
                                                    readonly STREAMING_SET_PERSONA: {
                                                        readonly actions: "sendParentCurrentPersona";
                                                    };
                                                };
                                                readonly states: {
                                                    readonly BufferIdle: {
                                                        readonly id: "BufferIdle";
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly on: {
                                                            readonly STREAMING_CHUNK: {
                                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                    type: "STREAMING_CHUNK";
                                                                    value: string;
                                                                }, import("./types").TTSEvent>) => void];
                                                                readonly target: "Buffering";
                                                            };
                                                        };
                                                    };
                                                    readonly Buffering: {
                                                        readonly id: "Buffering";
                                                        readonly on: {
                                                            readonly STREAMING_CHUNK: readonly [{
                                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                    type: "STREAMING_CHUNK";
                                                                    value: string;
                                                                }, import("./types").TTSEvent>) => void];
                                                                readonly target: "Buffering";
                                                                readonly reenter: true;
                                                            }];
                                                            readonly STREAMING_DONE: readonly [{
                                                                readonly target: "BufferingDone";
                                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                    type: "STREAMING_DONE";
                                                                }, import("./types").TTSEvent>) => void];
                                                            }];
                                                        };
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                    };
                                                    readonly BufferingDone: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly id: "BufferingDone";
                                                    };
                                                };
                                            };
                                            readonly Speaker: {
                                                readonly initial: "SpeakingIdle";
                                                readonly states: {
                                                    readonly SpeakingIdle: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly always: readonly [{
                                                            readonly target: "Speak";
                                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                getToken: {
                                                                    src: "getToken";
                                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                getToken: {
                                                                    src: "getToken";
                                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                createEventsFromStream: {
                                                                    src: "createEventsFromStream";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                ponyfill: {
                                                                    src: "ponyfill";
                                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                                start: {
                                                                    src: "start";
                                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                    id: string;
                                                                };
                                                            }>, never, never, never, never>];
                                                        }, {
                                                            readonly target: "PrepareSpeech";
                                                            readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                        }];
                                                        readonly after: {
                                                            readonly FILLER_DELAY: {
                                                                readonly target: "SpeakingIdle";
                                                                readonly reenter: true;
                                                                readonly actions: "addFiller";
                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                            };
                                                        };
                                                    };
                                                    readonly PrepareSpeech: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>];
                                                        readonly always: readonly [{
                                                            readonly target: "Speak";
                                                        }];
                                                    };
                                                    readonly Speak: {
                                                        readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                        readonly initial: "Go";
                                                        readonly on: {
                                                            readonly TTS_STARTED: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                    type: "TTS_STARTED";
                                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                            };
                                                            readonly SPEAK_COMPLETE: readonly [{
                                                                readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                    type: "SPEAK_COMPLETE";
                                                                }, undefined, any>;
                                                                readonly target: "SpeakingIdle";
                                                            }, {
                                                                readonly guard: "bufferIsNonEmpty";
                                                                readonly target: "SpeakingIdle";
                                                            }];
                                                        };
                                                        readonly states: {
                                                            readonly Go: {
                                                                readonly invoke: {
                                                                    readonly src: "start";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        wsaTTS: SpeechSynthesis;
                                                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                        ttsLexicon: string;
                                                                        voice: string;
                                                                        utterance: string;
                                                                    };
                                                                };
                                                                readonly on: {
                                                                    readonly CONTROL: "Paused";
                                                                };
                                                                readonly exit: "ttsStop";
                                                            };
                                                            readonly Paused: {
                                                                readonly on: {
                                                                    readonly CONTROL: "Go";
                                                                };
                                                            };
                                                        };
                                                    };
                                                };
                                            };
                                        };
                                    };
                                    readonly Speaking: {
                                        readonly initial: "Go";
                                        readonly on: {
                                            readonly STOP: {
                                                readonly target: "Idle";
                                            };
                                            readonly TTS_STARTED: {
                                                readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                    type: "TTS_STARTED";
                                                }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                            };
                                            readonly SPEAK_COMPLETE: {
                                                readonly target: "Idle";
                                            };
                                        };
                                        readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                        readonly states: {
                                            readonly Go: {
                                                readonly invoke: {
                                                    readonly src: "start";
                                                    readonly input: ({ context }: {
                                                        context: import("./types").TTSContext;
                                                        event: import("./types").TTSEvent;
                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                    }) => {
                                                        wsaTTS: SpeechSynthesis;
                                                        wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                        ttsLexicon: string;
                                                        voice: string;
                                                        utterance: string;
                                                    };
                                                };
                                                readonly on: {
                                                    readonly CONTROL: "Paused";
                                                };
                                                readonly exit: "ttsStop";
                                            };
                                            readonly Paused: {
                                                readonly on: {
                                                    readonly CONTROL: "Go";
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                            readonly Fail: {};
                            readonly GetToken: {
                                readonly invoke: {
                                    readonly id: "getAuthorizationToken";
                                    readonly input: ({ context }: {
                                        context: any;
                                    }) => {
                                        credentials: any;
                                    };
                                    readonly src: "getToken";
                                    readonly onDone: {
                                        readonly target: "Ponyfill";
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly onError: {
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                                        readonly target: "Fail";
                                    };
                                };
                            };
                            readonly Ponyfill: {
                                readonly invoke: {
                                    readonly id: "ponyTTS";
                                    readonly src: "ponyfill";
                                    readonly input: ({ context }: {
                                        context: import("./types").TTSContext;
                                        event: import("./types").TTSEvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                    }) => {
                                        audioContext: AudioContext;
                                        azureAuthorizationToken: string;
                                        azureRegion: string;
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
                asr: {
                    src: "asr";
                    logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                        [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                            query: string;
                        }, import("xstate").EventObject>>;
                    }, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        recStart: {
                            src: "recStart";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                query: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, {
                        type: "recStop";
                        params: unknown;
                    }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
                        Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
                    }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                        readonly id: "asr";
                        readonly context: ({ input }: {
                            spawn: {
                                <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_47 ? T_47 extends {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                } ? T_47 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_47["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_47["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_47 in import("xstate").RequiredActorOptions<T_47>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_47>>> : never : never : never) | ({
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_48 ? T_48 extends {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                } ? T_48 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_48["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_48["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_48 in import("xstate").RequiredActorOptions<T_48>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_48>>> : never : never : never) | ({
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_49 ? T_49 extends {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                } ? T_49 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_49["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_49["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_49 in import("xstate").RequiredActorOptions<T_49>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_49>>> : never : never : never) | ({
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } extends infer T_50 ? T_50 extends {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                } ? T_50 extends {
                                    src: TSrc_1;
                                } ? import("xstate").ConditionalRequired<[options?: {
                                    id?: T_50["id"];
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<T_50["logic"]>;
                                    syncSnapshot?: boolean;
                                } & { [K_50 in import("xstate").RequiredActorOptions<T_50>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_50>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    recStart: {
                                        src: "recStart";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, "src", TSrc_1>["logic"]>;
                                <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                                    id?: never;
                                    systemId?: string;
                                    input?: import("xstate").InputFrom<TLogic_1>;
                                    syncSnapshot?: boolean;
                                }): import("xstate").ActorRefFromLogic<TLogic_1>;
                            };
                            input: import("./types").ASRInit;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            asrDefaultCompleteTimeout: number;
                            asrDefaultNoInputTimeout: number;
                            locale: string;
                            audioContext: AudioContext;
                            azureCredentials: string | import("./types").AzureSpeechCredentials;
                            azureRegion: string;
                            azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                            speechRecognitionEndpointId: string;
                        };
                        readonly initial: "GetToken";
                        readonly on: {
                            readonly READY: {
                                readonly target: ".Ready";
                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "READY";
                                    value: {
                                        wsaASR: import("./types").MySpeechRecognition;
                                        wsaGrammarList: import("./types").MySpeechGrammarList;
                                    };
                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                    getToken: {
                                        src: "getToken";
                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    ponyfill: {
                                        src: "ponyfill";
                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    recStart: {
                                        src: "recStart";
                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                        id: string;
                                    };
                                    nluPromise: {
                                        src: "nluPromise";
                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                            query: string;
                                        }, import("xstate").EventObject>;
                                        id: string;
                                    };
                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                    type: "READY";
                                    value: {
                                        wsaASR: import("./types").MySpeechRecognition;
                                        wsaGrammarList: import("./types").MySpeechGrammarList;
                                    };
                                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                            };
                        };
                        readonly states: {
                            readonly Fail: {};
                            readonly Ready: {
                                readonly on: {
                                    readonly START: {
                                        readonly target: "Recognising";
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "START";
                                            value?: import("./types").RecogniseParameters;
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            recStart: {
                                                src: "recStart";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>;
                                    };
                                };
                            };
                            readonly Recognising: {
                                readonly initial: "WaitForRecogniser";
                                readonly invoke: {
                                    readonly id: "recStart";
                                    readonly input: ({ context }: {
                                        context: any;
                                    }) => {
                                        wsaASR: any;
                                        wsaGrammarList: any;
                                        locale: any;
                                        phrases: any;
                                    };
                                    readonly src: "recStart";
                                };
                                readonly exit: "recStop";
                                readonly on: {
                                    readonly RESULT: {
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: import("./types").Hypothesis[];
                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            recStart: {
                                                src: "recStart";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                            type: "RESULT";
                                            value: import("./types").Hypothesis[];
                                        }, undefined, import("./types").ASREvent>];
                                        readonly target: ".Match";
                                    };
                                    readonly RECOGNISED: readonly [{
                                        readonly target: ".NLURequest";
                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                                            type: "RECOGNISED";
                                        }>) => boolean;
                                    }, {
                                        readonly target: "Ready";
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "RECOGNISED";
                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    }];
                                    readonly CONTROL: {
                                        readonly target: "Paused";
                                    };
                                    readonly STOP: {
                                        readonly target: "Ready";
                                    };
                                    readonly NOINPUT: {
                                        readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                            type: "NOINPUT";
                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                        readonly target: "Ready";
                                    };
                                };
                                readonly states: {
                                    readonly WaitForRecogniser: {
                                        readonly on: {
                                            readonly STARTED: {
                                                readonly target: "NoInput";
                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "STARTED";
                                                    value: {
                                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                                    };
                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                    getToken: {
                                                        src: "getToken";
                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    ponyfill: {
                                                        src: "ponyfill";
                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    recStart: {
                                                        src: "recStart";
                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                    nluPromise: {
                                                        src: "nluPromise";
                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                            query: string;
                                                        }, import("xstate").EventObject>;
                                                        id: string;
                                                    };
                                                }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                    type: "STARTED";
                                                    value: {
                                                        wsaASRinstance: import("./types").MySpeechRecognition;
                                                    };
                                                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                            };
                                        };
                                    };
                                    readonly NoInput: {
                                        readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                        readonly on: {
                                            readonly STARTSPEECH: {
                                                readonly target: "InProgress";
                                                readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                    type: "STARTSPEECH";
                                                }, undefined, import("./types").ASREvent>;
                                            };
                                        };
                                        readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                                    };
                                    readonly InProgress: {
                                        readonly entry: () => void;
                                    };
                                    readonly Match: {
                                        readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                    };
                                    readonly NLURequest: {
                                        readonly invoke: {
                                            readonly src: "nluPromise";
                                            readonly input: ({ context }: {
                                                context: import("./types").ASRContext;
                                                event: import("./types").ASREvent;
                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                            }) => {
                                                endpoint: string;
                                                key: string;
                                                projectName: string;
                                                deploymentName: string;
                                                query: string;
                                            };
                                            readonly onDone: readonly [{
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                readonly target: "#asr.Ready";
                                                readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                            }, {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                readonly target: "#asr.Ready";
                                            }];
                                            readonly onError: {
                                                readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                readonly target: "#asr.Ready";
                                            };
                                        };
                                    };
                                };
                            };
                            readonly Paused: {
                                readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                readonly on: {
                                    readonly CONTROL: {
                                        readonly target: "Recognising";
                                    };
                                };
                            };
                            readonly GetToken: {
                                readonly invoke: {
                                    readonly id: "getAuthorizationToken";
                                    readonly input: ({ context }: {
                                        context: any;
                                    }) => {
                                        credentials: any;
                                    };
                                    readonly src: "getToken";
                                    readonly onDone: {
                                        readonly target: "Ponyfill";
                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            recStart: {
                                                src: "recStart";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            nluPromise: {
                                                src: "nluPromise";
                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    };
                                    readonly onError: {
                                        readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                                        readonly target: "Fail";
                                    };
                                };
                            };
                            readonly Ponyfill: {
                                readonly invoke: {
                                    readonly id: "ponyASR";
                                    readonly src: "ponyfill";
                                    readonly input: ({ context }: {
                                        context: import("./types").ASRContext;
                                        event: import("./types").ASREvent;
                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                    }) => {
                                        azureRegion: string;
                                        audioContext: AudioContext;
                                        azureAuthorizationToken: string;
                                        locale: string;
                                        speechRecognitionEndpointId: string;
                                    };
                                };
                            };
                        };
                    }>;
                    id: string;
                };
            }>, never, never, never, never>, () => void];
        };
        readonly Active: {
            readonly type: "parallel";
            readonly states: {
                readonly AsrTtsSpawner: {
                    readonly initial: "Idle";
                    readonly states: {
                        readonly Idle: {
                            readonly on: {
                                readonly PREPARE: "CreateAudioContext";
                            };
                        };
                        readonly CreateAudioContext: {
                            readonly invoke: {
                                readonly id: "createAudioContext";
                                readonly src: "audioContext";
                                readonly onDone: {
                                    readonly target: "Spawn";
                                    readonly actions: import("xstate").ActionFunction<SSContext, import("xstate").DoneActorEvent<AudioContext, string>, SpeechStateEvent, undefined, import("xstate").Values<{
                                        audioContext: {
                                            src: "audioContext";
                                            logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        tts: {
                                            src: "tts";
                                            logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                ttsStop: {
                                                    type: "ttsStop";
                                                    params: unknown;
                                                };
                                                addFiller: {
                                                    type: "addFiller";
                                                    params: {};
                                                };
                                                assignCurrentVoice: {
                                                    type: "assignCurrentVoice";
                                                    params: {};
                                                };
                                                sendParentCurrentPersona: {
                                                    type: "sendParentCurrentPersona";
                                                    params: {};
                                                };
                                            }>, import("xstate").Values<{
                                                bufferContainsUtterancePartReadyToBeSpoken: {
                                                    type: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    params: unknown;
                                                };
                                                bufferIsNonEmpty: {
                                                    type: "bufferIsNonEmpty";
                                                    params: unknown;
                                                };
                                            }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
                                                Ready?: "Idle" | {
                                                    BufferedSpeaker?: Required<{
                                                        Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                                                        Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                                                            Speak?: "Go" | "Paused";
                                                        };
                                                    }>;
                                                    Speaking?: "Go" | "Paused";
                                                };
                                            }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "tts";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_51 ? T_51 extends {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_51 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_51["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_51["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_51 in import("xstate").RequiredActorOptions<T_51>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_51>>> : never : never : never) | ({
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_52 ? T_52 extends {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_52 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_52["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_52["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_52 in import("xstate").RequiredActorOptions<T_52>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_52>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_53 ? T_53 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_53 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_53["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_53["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_53 in import("xstate").RequiredActorOptions<T_53>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_53>>> : never : never : never) | ({
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_54 ? T_54 extends {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_54 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_54["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_54["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_54 in import("xstate").RequiredActorOptions<T_54>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_54>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").TTSInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    ttsDefaultVoice: string;
                                                    ttsLexicon: string;
                                                    audioContext: AudioContext;
                                                    azureCredentials: string | import("./types").AzureSpeechCredentials;
                                                    azureRegion: string;
                                                    buffer: string;
                                                };
                                                readonly initial: "GetToken";
                                                readonly on: {
                                                    readonly READY: {
                                                        readonly target: ".Ready";
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaTTS: SpeechSynthesis;
                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                            };
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaTTS: SpeechSynthesis;
                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                            };
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                                    };
                                                    readonly ERROR: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "ERROR";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Ready: {
                                                        readonly initial: "Idle";
                                                        readonly states: {
                                                            readonly Idle: {
                                                                readonly on: {
                                                                    readonly SPEAK: readonly [{
                                                                        readonly target: "BufferedSpeaker";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                            type: "SPEAK";
                                                                            value: import("./types").Agenda;
                                                                        }>) => boolean;
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "SPEAK";
                                                                            value: import("./types").Agenda;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            getToken: {
                                                                                src: "getToken";
                                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    }, {
                                                                        readonly target: "Speaking";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "SPEAK";
                                                                            value: import("./types").Agenda;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            getToken: {
                                                                                src: "getToken";
                                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    }];
                                                                };
                                                            };
                                                            readonly BufferedSpeaker: {
                                                                readonly type: "parallel";
                                                                readonly invoke: {
                                                                    readonly id: "createEventsFromStream";
                                                                    readonly src: "createEventsFromStream";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => import("./types").Agenda;
                                                                };
                                                                readonly on: {
                                                                    readonly STOP: {
                                                                        readonly target: "Idle";
                                                                    };
                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                            type: "SPEAK_COMPLETE";
                                                                        }, undefined, any>;
                                                                        readonly target: "Idle";
                                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "SPEAK_COMPLETE";
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                                                    }];
                                                                };
                                                                readonly states: {
                                                                    readonly Buffer: {
                                                                        readonly initial: "BufferIdle";
                                                                        readonly on: {
                                                                            readonly STREAMING_SET_VOICE: {
                                                                                readonly actions: "assignCurrentVoice";
                                                                            };
                                                                            readonly STREAMING_SET_PERSONA: {
                                                                                readonly actions: "sendParentCurrentPersona";
                                                                            };
                                                                        };
                                                                        readonly states: {
                                                                            readonly BufferIdle: {
                                                                                readonly id: "BufferIdle";
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly on: {
                                                                                    readonly STREAMING_CHUNK: {
                                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                            type: "STREAMING_CHUNK";
                                                                                            value: string;
                                                                                        }, import("./types").TTSEvent>) => void];
                                                                                        readonly target: "Buffering";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly Buffering: {
                                                                                readonly id: "Buffering";
                                                                                readonly on: {
                                                                                    readonly STREAMING_CHUNK: readonly [{
                                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                            type: "STREAMING_CHUNK";
                                                                                            value: string;
                                                                                        }, import("./types").TTSEvent>) => void];
                                                                                        readonly target: "Buffering";
                                                                                        readonly reenter: true;
                                                                                    }];
                                                                                    readonly STREAMING_DONE: readonly [{
                                                                                        readonly target: "BufferingDone";
                                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                            type: "STREAMING_DONE";
                                                                                        }, import("./types").TTSEvent>) => void];
                                                                                    }];
                                                                                };
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    getToken: {
                                                                                        src: "getToken";
                                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                            };
                                                                            readonly BufferingDone: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly id: "BufferingDone";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Speaker: {
                                                                        readonly initial: "SpeakingIdle";
                                                                        readonly states: {
                                                                            readonly SpeakingIdle: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly always: readonly [{
                                                                                    readonly target: "Speak";
                                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        getToken: {
                                                                                            src: "getToken";
                                                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        getToken: {
                                                                                            src: "getToken";
                                                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>];
                                                                                }, {
                                                                                    readonly target: "PrepareSpeech";
                                                                                    readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                                }];
                                                                                readonly after: {
                                                                                    readonly FILLER_DELAY: {
                                                                                        readonly target: "SpeakingIdle";
                                                                                        readonly reenter: true;
                                                                                        readonly actions: "addFiller";
                                                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly PrepareSpeech: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    getToken: {
                                                                                        src: "getToken";
                                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                                readonly always: readonly [{
                                                                                    readonly target: "Speak";
                                                                                }];
                                                                            };
                                                                            readonly Speak: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly initial: "Go";
                                                                                readonly on: {
                                                                                    readonly TTS_STARTED: {
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                            type: "TTS_STARTED";
                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                                                    };
                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                            type: "SPEAK_COMPLETE";
                                                                                        }, undefined, any>;
                                                                                        readonly target: "SpeakingIdle";
                                                                                    }, {
                                                                                        readonly guard: "bufferIsNonEmpty";
                                                                                        readonly target: "SpeakingIdle";
                                                                                    }];
                                                                                };
                                                                                readonly states: {
                                                                                    readonly Go: {
                                                                                        readonly invoke: {
                                                                                            readonly src: "start";
                                                                                            readonly input: ({ context }: {
                                                                                                context: import("./types").TTSContext;
                                                                                                event: import("./types").TTSEvent;
                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                            }) => {
                                                                                                wsaTTS: SpeechSynthesis;
                                                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                                                ttsLexicon: string;
                                                                                                voice: string;
                                                                                                utterance: string;
                                                                                            };
                                                                                        };
                                                                                        readonly on: {
                                                                                            readonly CONTROL: "Paused";
                                                                                        };
                                                                                        readonly exit: "ttsStop";
                                                                                    };
                                                                                    readonly Paused: {
                                                                                        readonly on: {
                                                                                            readonly CONTROL: "Go";
                                                                                        };
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                            readonly Speaking: {
                                                                readonly initial: "Go";
                                                                readonly on: {
                                                                    readonly STOP: {
                                                                        readonly target: "Idle";
                                                                    };
                                                                    readonly TTS_STARTED: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "TTS_STARTED";
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                                    };
                                                                    readonly SPEAK_COMPLETE: {
                                                                        readonly target: "Idle";
                                                                    };
                                                                };
                                                                readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                                readonly states: {
                                                                    readonly Go: {
                                                                        readonly invoke: {
                                                                            readonly src: "start";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                                ttsLexicon: string;
                                                                                voice: string;
                                                                                utterance: string;
                                                                            };
                                                                        };
                                                                        readonly on: {
                                                                            readonly CONTROL: "Paused";
                                                                        };
                                                                        readonly exit: "ttsStop";
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly on: {
                                                                            readonly CONTROL: "Go";
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly Fail: {};
                                                    readonly GetToken: {
                                                        readonly invoke: {
                                                            readonly id: "getAuthorizationToken";
                                                            readonly input: ({ context }: {
                                                                context: any;
                                                            }) => {
                                                                credentials: any;
                                                            };
                                                            readonly src: "getToken";
                                                            readonly onDone: {
                                                                readonly target: "Ponyfill";
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly onError: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                                                                readonly target: "Fail";
                                                            };
                                                        };
                                                    };
                                                    readonly Ponyfill: {
                                                        readonly invoke: {
                                                            readonly id: "ponyTTS";
                                                            readonly src: "ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                azureRegion: string;
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        asr: {
                                            src: "asr";
                                            logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                recStart: {
                                                    src: "recStart";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, {
                                                type: "recStop";
                                                params: unknown;
                                            }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
                                                Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
                                            }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "asr";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_55 ? T_55 extends {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_55 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_55["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_55["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_55 in import("xstate").RequiredActorOptions<T_55>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_55>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_56 ? T_56 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_56 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_56["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_56["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_56 in import("xstate").RequiredActorOptions<T_56>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_56>>> : never : never : never) | ({
                                                            src: "recStart";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_57 ? T_57 extends {
                                                            src: "recStart";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_57 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_57["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_57["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_57 in import("xstate").RequiredActorOptions<T_57>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_57>>> : never : never : never) | ({
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_58 ? T_58 extends {
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_58 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_58["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_58["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_58 in import("xstate").RequiredActorOptions<T_58>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_58>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            recStart: {
                                                                src: "recStart";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc_1>["logic"]>;
                                                        <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic_1>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic_1>;
                                                    };
                                                    input: import("./types").ASRInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    asrDefaultCompleteTimeout: number;
                                                    asrDefaultNoInputTimeout: number;
                                                    locale: string;
                                                    audioContext: AudioContext;
                                                    azureCredentials: string | import("./types").AzureSpeechCredentials;
                                                    azureRegion: string;
                                                    azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                                                    speechRecognitionEndpointId: string;
                                                };
                                                readonly initial: "GetToken";
                                                readonly on: {
                                                    readonly READY: {
                                                        readonly target: ".Ready";
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaASR: import("./types").MySpeechRecognition;
                                                                wsaGrammarList: import("./types").MySpeechGrammarList;
                                                            };
                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            recStart: {
                                                                src: "recStart";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaASR: import("./types").MySpeechRecognition;
                                                                wsaGrammarList: import("./types").MySpeechGrammarList;
                                                            };
                                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Fail: {};
                                                    readonly Ready: {
                                                        readonly on: {
                                                            readonly START: {
                                                                readonly target: "Recognising";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "START";
                                                                    value?: import("./types").RecogniseParameters;
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    recStart: {
                                                                        src: "recStart";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                        };
                                                    };
                                                    readonly Recognising: {
                                                        readonly initial: "WaitForRecogniser";
                                                        readonly invoke: {
                                                            readonly id: "recStart";
                                                            readonly input: ({ context }: {
                                                                context: any;
                                                            }) => {
                                                                wsaASR: any;
                                                                wsaGrammarList: any;
                                                                locale: any;
                                                                phrases: any;
                                                            };
                                                            readonly src: "recStart";
                                                        };
                                                        readonly exit: "recStop";
                                                        readonly on: {
                                                            readonly RESULT: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: import("./types").Hypothesis[];
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    recStart: {
                                                                        src: "recStart";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: import("./types").Hypothesis[];
                                                                }, undefined, import("./types").ASREvent>];
                                                                readonly target: ".Match";
                                                            };
                                                            readonly RECOGNISED: readonly [{
                                                                readonly target: ".NLURequest";
                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                                                                    type: "RECOGNISED";
                                                                }>) => boolean;
                                                            }, {
                                                                readonly target: "Ready";
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RECOGNISED";
                                                                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                            }];
                                                            readonly CONTROL: {
                                                                readonly target: "Paused";
                                                            };
                                                            readonly STOP: {
                                                                readonly target: "Ready";
                                                            };
                                                            readonly NOINPUT: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "NOINPUT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                                                readonly target: "Ready";
                                                            };
                                                        };
                                                        readonly states: {
                                                            readonly WaitForRecogniser: {
                                                                readonly on: {
                                                                    readonly STARTED: {
                                                                        readonly target: "NoInput";
                                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                            getToken: {
                                                                                src: "getToken";
                                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            recStart: {
                                                                                src: "recStart";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            nluPromise: {
                                                                                src: "nluPromise";
                                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                                    query: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                    };
                                                                };
                                                            };
                                                            readonly NoInput: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                readonly on: {
                                                                    readonly STARTSPEECH: {
                                                                        readonly target: "InProgress";
                                                                        readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                                            type: "STARTSPEECH";
                                                                        }, undefined, import("./types").ASREvent>;
                                                                    };
                                                                };
                                                                readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                                                            };
                                                            readonly InProgress: {
                                                                readonly entry: () => void;
                                                            };
                                                            readonly Match: {
                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                            };
                                                            readonly NLURequest: {
                                                                readonly invoke: {
                                                                    readonly src: "nluPromise";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").ASRContext;
                                                                        event: import("./types").ASREvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        endpoint: string;
                                                                        key: string;
                                                                        projectName: string;
                                                                        deploymentName: string;
                                                                        query: string;
                                                                    };
                                                                    readonly onDone: readonly [{
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                        readonly target: "#asr.Ready";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                                                    }, {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                        readonly target: "#asr.Ready";
                                                                    }];
                                                                    readonly onError: {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                        readonly target: "#asr.Ready";
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly Paused: {
                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                                        readonly on: {
                                                            readonly CONTROL: {
                                                                readonly target: "Recognising";
                                                            };
                                                        };
                                                    };
                                                    readonly GetToken: {
                                                        readonly invoke: {
                                                            readonly id: "getAuthorizationToken";
                                                            readonly input: ({ context }: {
                                                                context: any;
                                                            }) => {
                                                                credentials: any;
                                                            };
                                                            readonly src: "getToken";
                                                            readonly onDone: {
                                                                readonly target: "Ponyfill";
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    recStart: {
                                                                        src: "recStart";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly onError: {
                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                                                                readonly target: "Fail";
                                                            };
                                                        };
                                                    };
                                                    readonly Ponyfill: {
                                                        readonly invoke: {
                                                            readonly id: "ponyASR";
                                                            readonly src: "ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").ASRContext;
                                                                event: import("./types").ASREvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                azureRegion: string;
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                locale: string;
                                                                speechRecognitionEndpointId: string;
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>;
                                };
                            };
                        };
                        readonly Spawn: {
                            readonly entry: readonly [{
                                readonly type: "spawnTTS";
                            }, {
                                readonly type: "spawnASR";
                            }];
                            readonly after: {
                                readonly 300000: {
                                    readonly target: "Spawn";
                                    readonly reenter: true;
                                    readonly actions: readonly [({}: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => void, import("xstate").StopAction<SSContext, SpeechStateEvent, undefined, SpeechStateEvent>, import("xstate").StopAction<SSContext, SpeechStateEvent, undefined, SpeechStateEvent>, import("xstate").ActionFunction<SSContext, SpeechStateEvent, SpeechStateEvent, undefined, import("xstate").Values<{
                                        audioContext: {
                                            src: "audioContext";
                                            logic: import("xstate").PromiseActorLogic<AudioContext, void, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        tts: {
                                            src: "tts";
                                            logic: import("xstate").StateMachine<import("./types").TTSContext, import("./types").TTSEvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                createEventsFromStream: {
                                                    src: "createEventsFromStream";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                start: {
                                                    src: "start";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, import("xstate").Values<{
                                                ttsStop: {
                                                    type: "ttsStop";
                                                    params: unknown;
                                                };
                                                addFiller: {
                                                    type: "addFiller";
                                                    params: {};
                                                };
                                                assignCurrentVoice: {
                                                    type: "assignCurrentVoice";
                                                    params: {};
                                                };
                                                sendParentCurrentPersona: {
                                                    type: "sendParentCurrentPersona";
                                                    params: {};
                                                };
                                            }>, import("xstate").Values<{
                                                bufferContainsUtterancePartReadyToBeSpoken: {
                                                    type: "bufferContainsUtterancePartReadyToBeSpoken";
                                                    params: unknown;
                                                };
                                                bufferIsNonEmpty: {
                                                    type: "bufferIsNonEmpty";
                                                    params: unknown;
                                                };
                                            }>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
                                                Ready?: "Idle" | {
                                                    BufferedSpeaker?: Required<{
                                                        Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
                                                        Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                                                            Speak?: "Go" | "Paused";
                                                        };
                                                    }>;
                                                    Speaking?: "Go" | "Paused";
                                                };
                                            }, string, import("./types").TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "tts";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_59 ? T_59 extends {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_59 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_59["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_59["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_59 in import("xstate").RequiredActorOptions<T_59>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_59>>> : never : never : never) | ({
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_60 ? T_60 extends {
                                                            src: "createEventsFromStream";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_60 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_60["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_60["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_60 in import("xstate").RequiredActorOptions<T_60>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_60>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_61 ? T_61 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_61 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_61["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_61["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_61 in import("xstate").RequiredActorOptions<T_61>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_61>>> : never : never : never) | ({
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_62 ? T_62 extends {
                                                            src: "start";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_62 extends {
                                                            src: TSrc;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_62["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_62["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_62 in import("xstate").RequiredActorOptions<T_62>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_62>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc>["logic"]>;
                                                        <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic>;
                                                    };
                                                    input: import("./types").TTSInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    ttsDefaultVoice: string;
                                                    ttsLexicon: string;
                                                    audioContext: AudioContext;
                                                    azureCredentials: string | import("./types").AzureSpeechCredentials;
                                                    azureRegion: string;
                                                    buffer: string;
                                                };
                                                readonly initial: "GetToken";
                                                readonly on: {
                                                    readonly READY: {
                                                        readonly target: ".Ready";
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaTTS: SpeechSynthesis;
                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                            };
                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            createEventsFromStream: {
                                                                src: "createEventsFromStream";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            start: {
                                                                src: "start";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaTTS: SpeechSynthesis;
                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                            };
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                                    };
                                                    readonly ERROR: {
                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                            type: "ERROR";
                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Ready: {
                                                        readonly initial: "Idle";
                                                        readonly states: {
                                                            readonly Idle: {
                                                                readonly on: {
                                                                    readonly SPEAK: readonly [{
                                                                        readonly target: "BufferedSpeaker";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, {
                                                                            type: "SPEAK";
                                                                            value: import("./types").Agenda;
                                                                        }>) => boolean;
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "SPEAK";
                                                                            value: import("./types").Agenda;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            getToken: {
                                                                                src: "getToken";
                                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    }, {
                                                                        readonly target: "Speaking";
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "SPEAK";
                                                                            value: import("./types").Agenda;
                                                                        }, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                            getToken: {
                                                                                src: "getToken";
                                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            createEventsFromStream: {
                                                                                src: "createEventsFromStream";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            start: {
                                                                                src: "start";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>;
                                                                    }];
                                                                };
                                                            };
                                                            readonly BufferedSpeaker: {
                                                                readonly type: "parallel";
                                                                readonly invoke: {
                                                                    readonly id: "createEventsFromStream";
                                                                    readonly src: "createEventsFromStream";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").TTSContext;
                                                                        event: import("./types").TTSEvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                    }) => import("./types").Agenda;
                                                                };
                                                                readonly on: {
                                                                    readonly STOP: {
                                                                        readonly target: "Idle";
                                                                    };
                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                            type: "SPEAK_COMPLETE";
                                                                        }, undefined, any>;
                                                                        readonly target: "Idle";
                                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "SPEAK_COMPLETE";
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                                                                    }];
                                                                };
                                                                readonly states: {
                                                                    readonly Buffer: {
                                                                        readonly initial: "BufferIdle";
                                                                        readonly on: {
                                                                            readonly STREAMING_SET_VOICE: {
                                                                                readonly actions: "assignCurrentVoice";
                                                                            };
                                                                            readonly STREAMING_SET_PERSONA: {
                                                                                readonly actions: "sendParentCurrentPersona";
                                                                            };
                                                                        };
                                                                        readonly states: {
                                                                            readonly BufferIdle: {
                                                                                readonly id: "BufferIdle";
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly on: {
                                                                                    readonly STREAMING_CHUNK: {
                                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                            type: "STREAMING_CHUNK";
                                                                                            value: string;
                                                                                        }, import("./types").TTSEvent>) => void];
                                                                                        readonly target: "Buffering";
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly Buffering: {
                                                                                readonly id: "Buffering";
                                                                                readonly on: {
                                                                                    readonly STREAMING_CHUNK: readonly [{
                                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                            type: "STREAMING_CHUNK";
                                                                                            value: string;
                                                                                        }, import("./types").TTSEvent>) => void];
                                                                                        readonly target: "Buffering";
                                                                                        readonly reenter: true;
                                                                                    }];
                                                                                    readonly STREAMING_DONE: readonly [{
                                                                                        readonly target: "BufferingDone";
                                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, {
                                                                                            type: "STREAMING_DONE";
                                                                                        }, import("./types").TTSEvent>) => void];
                                                                                    }];
                                                                                };
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    getToken: {
                                                                                        src: "getToken";
                                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                            };
                                                                            readonly BufferingDone: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly id: "BufferingDone";
                                                                            };
                                                                        };
                                                                    };
                                                                    readonly Speaker: {
                                                                        readonly initial: "SpeakingIdle";
                                                                        readonly states: {
                                                                            readonly SpeakingIdle: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly always: readonly [{
                                                                                    readonly target: "Speak";
                                                                                    readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, import("./types").TTSEvent, undefined, any>;
                                                                                    readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        getToken: {
                                                                                            src: "getToken";
                                                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                        getToken: {
                                                                                            src: "getToken";
                                                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        createEventsFromStream: {
                                                                                            src: "createEventsFromStream";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        ponyfill: {
                                                                                            src: "ponyfill";
                                                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                        start: {
                                                                                            src: "start";
                                                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                            id: string;
                                                                                        };
                                                                                    }>, never, never, never, never>];
                                                                                }, {
                                                                                    readonly target: "PrepareSpeech";
                                                                                    readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                                                                }];
                                                                                readonly after: {
                                                                                    readonly FILLER_DELAY: {
                                                                                        readonly target: "SpeakingIdle";
                                                                                        readonly reenter: true;
                                                                                        readonly actions: "addFiller";
                                                                                        readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").TTSContext, import("./types").TTSEvent>) => boolean;
                                                                                    };
                                                                                };
                                                                            };
                                                                            readonly PrepareSpeech: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void, import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                                    getToken: {
                                                                                        src: "getToken";
                                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    createEventsFromStream: {
                                                                                        src: "createEventsFromStream";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    ponyfill: {
                                                                                        src: "ponyfill";
                                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                    start: {
                                                                                        src: "start";
                                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                                        id: string;
                                                                                    };
                                                                                }>, never, never, never, never>];
                                                                                readonly always: readonly [{
                                                                                    readonly target: "Speak";
                                                                                }];
                                                                            };
                                                                            readonly Speak: {
                                                                                readonly entry: readonly [({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent>) => void];
                                                                                readonly initial: "Go";
                                                                                readonly on: {
                                                                                    readonly TTS_STARTED: {
                                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                                            type: "TTS_STARTED";
                                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                                                    };
                                                                                    readonly SPEAK_COMPLETE: readonly [{
                                                                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<import("./types").TTSContext, {
                                                                                            type: "SPEAK_COMPLETE";
                                                                                        }, undefined, any>;
                                                                                        readonly target: "SpeakingIdle";
                                                                                    }, {
                                                                                        readonly guard: "bufferIsNonEmpty";
                                                                                        readonly target: "SpeakingIdle";
                                                                                    }];
                                                                                };
                                                                                readonly states: {
                                                                                    readonly Go: {
                                                                                        readonly invoke: {
                                                                                            readonly src: "start";
                                                                                            readonly input: ({ context }: {
                                                                                                context: import("./types").TTSContext;
                                                                                                event: import("./types").TTSEvent;
                                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                                            }) => {
                                                                                                wsaTTS: SpeechSynthesis;
                                                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                                                ttsLexicon: string;
                                                                                                voice: string;
                                                                                                utterance: string;
                                                                                            };
                                                                                        };
                                                                                        readonly on: {
                                                                                            readonly CONTROL: "Paused";
                                                                                        };
                                                                                        readonly exit: "ttsStop";
                                                                                    };
                                                                                    readonly Paused: {
                                                                                        readonly on: {
                                                                                            readonly CONTROL: "Go";
                                                                                        };
                                                                                    };
                                                                                };
                                                                            };
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                            readonly Speaking: {
                                                                readonly initial: "Go";
                                                                readonly on: {
                                                                    readonly STOP: {
                                                                        readonly target: "Idle";
                                                                    };
                                                                    readonly TTS_STARTED: {
                                                                        readonly actions: import("xstate").ActionFunction<import("./types").TTSContext, {
                                                                            type: "TTS_STARTED";
                                                                        }, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                                    };
                                                                    readonly SPEAK_COMPLETE: {
                                                                        readonly target: "Idle";
                                                                    };
                                                                };
                                                                readonly exit: import("xstate").ActionFunction<import("./types").TTSContext, import("./types").TTSEvent, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                                                readonly states: {
                                                                    readonly Go: {
                                                                        readonly invoke: {
                                                                            readonly src: "start";
                                                                            readonly input: ({ context }: {
                                                                                context: import("./types").TTSContext;
                                                                                event: import("./types").TTSEvent;
                                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                                            }) => {
                                                                                wsaTTS: SpeechSynthesis;
                                                                                wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                                                ttsLexicon: string;
                                                                                voice: string;
                                                                                utterance: string;
                                                                            };
                                                                        };
                                                                        readonly on: {
                                                                            readonly CONTROL: "Paused";
                                                                        };
                                                                        readonly exit: "ttsStop";
                                                                    };
                                                                    readonly Paused: {
                                                                        readonly on: {
                                                                            readonly CONTROL: "Go";
                                                                        };
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly Fail: {};
                                                    readonly GetToken: {
                                                        readonly invoke: {
                                                            readonly id: "getAuthorizationToken";
                                                            readonly input: ({ context }: {
                                                                context: any;
                                                            }) => {
                                                                credentials: any;
                                                            };
                                                            readonly src: "getToken";
                                                            readonly onDone: {
                                                                readonly target: "Ponyfill";
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").DoneActorEvent<string, string>, import("./types").TTSEvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    createEventsFromStream: {
                                                                        src: "createEventsFromStream";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, import("./types").Agenda, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").TTSPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    start: {
                                                                        src: "start";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly onError: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<import("./types").TTSContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").TTSEvent>) => void];
                                                                readonly target: "Fail";
                                                            };
                                                        };
                                                    };
                                                    readonly Ponyfill: {
                                                        readonly invoke: {
                                                            readonly id: "ponyTTS";
                                                            readonly src: "ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").TTSContext;
                                                                event: import("./types").TTSEvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").TTSContext, import("./types").TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").TTSEvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                azureRegion: string;
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                        asr: {
                                            src: "asr";
                                            logic: import("xstate").StateMachine<import("./types").ASRContext, import("./types").ASREvent, {
                                                [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                    query: string;
                                                }, import("xstate").EventObject>>;
                                            }, import("xstate").Values<{
                                                getToken: {
                                                    src: "getToken";
                                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                ponyfill: {
                                                    src: "ponyfill";
                                                    logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                recStart: {
                                                    src: "recStart";
                                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                                nluPromise: {
                                                    src: "nluPromise";
                                                    logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                        query: string;
                                                    }, import("xstate").EventObject>;
                                                    id: string;
                                                };
                                            }>, {
                                                type: "recStop";
                                                params: unknown;
                                            }, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
                                                Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
                                            }, string, import("./types").ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
                                                readonly id: "asr";
                                                readonly context: ({ input }: {
                                                    spawn: {
                                                        <TSrc_1 extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc_1, ...[options]: ({
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_63 ? T_63 extends {
                                                            src: "getToken";
                                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_63 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_63["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_63["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_63 in import("xstate").RequiredActorOptions<T_63>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_63>>> : never : never : never) | ({
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_64 ? T_64 extends {
                                                            src: "ponyfill";
                                                            logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_64 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_64["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_64["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_64 in import("xstate").RequiredActorOptions<T_64>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_64>>> : never : never : never) | ({
                                                            src: "recStart";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_65 ? T_65 extends {
                                                            src: "recStart";
                                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_65 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_65["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_65["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_65 in import("xstate").RequiredActorOptions<T_65>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_65>>> : never : never : never) | ({
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } extends infer T_66 ? T_66 extends {
                                                            src: "nluPromise";
                                                            logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                query: string;
                                                            }, import("xstate").EventObject>;
                                                            id: string;
                                                        } ? T_66 extends {
                                                            src: TSrc_1;
                                                        } ? import("xstate").ConditionalRequired<[options?: {
                                                            id?: T_66["id"];
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<T_66["logic"]>;
                                                            syncSnapshot?: boolean;
                                                        } & { [K_66 in import("xstate").RequiredActorOptions<T_66>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_66>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            recStart: {
                                                                src: "recStart";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, "src", TSrc_1>["logic"]>;
                                                        <TLogic_1 extends import("xstate").AnyActorLogic>(src: TLogic_1, options?: {
                                                            id?: never;
                                                            systemId?: string;
                                                            input?: import("xstate").InputFrom<TLogic_1>;
                                                            syncSnapshot?: boolean;
                                                        }): import("xstate").ActorRefFromLogic<TLogic_1>;
                                                    };
                                                    input: import("./types").ASRInit;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    asrDefaultCompleteTimeout: number;
                                                    asrDefaultNoInputTimeout: number;
                                                    locale: string;
                                                    audioContext: AudioContext;
                                                    azureCredentials: string | import("./types").AzureSpeechCredentials;
                                                    azureRegion: string;
                                                    azureLanguageCredentials: import("./types").AzureLanguageCredentials;
                                                    speechRecognitionEndpointId: string;
                                                };
                                                readonly initial: "GetToken";
                                                readonly on: {
                                                    readonly READY: {
                                                        readonly target: ".Ready";
                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaASR: import("./types").MySpeechRecognition;
                                                                wsaGrammarList: import("./types").MySpeechGrammarList;
                                                            };
                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                            getToken: {
                                                                src: "getToken";
                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            ponyfill: {
                                                                src: "ponyfill";
                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            recStart: {
                                                                src: "recStart";
                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                            nluPromise: {
                                                                src: "nluPromise";
                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                    query: string;
                                                                }, import("xstate").EventObject>;
                                                                id: string;
                                                            };
                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                            type: "READY";
                                                            value: {
                                                                wsaASR: import("./types").MySpeechRecognition;
                                                                wsaGrammarList: import("./types").MySpeechGrammarList;
                                                            };
                                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                    };
                                                };
                                                readonly states: {
                                                    readonly Fail: {};
                                                    readonly Ready: {
                                                        readonly on: {
                                                            readonly START: {
                                                                readonly target: "Recognising";
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "START";
                                                                    value?: import("./types").RecogniseParameters;
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    recStart: {
                                                                        src: "recStart";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>;
                                                            };
                                                        };
                                                    };
                                                    readonly Recognising: {
                                                        readonly initial: "WaitForRecogniser";
                                                        readonly invoke: {
                                                            readonly id: "recStart";
                                                            readonly input: ({ context }: {
                                                                context: any;
                                                            }) => {
                                                                wsaASR: any;
                                                                wsaGrammarList: any;
                                                                locale: any;
                                                                phrases: any;
                                                            };
                                                            readonly src: "recStart";
                                                        };
                                                        readonly exit: "recStop";
                                                        readonly on: {
                                                            readonly RESULT: {
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: import("./types").Hypothesis[];
                                                                }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    recStart: {
                                                                        src: "recStart";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>, import("xstate").CancelAction<import("./types").ASRContext, {
                                                                    type: "RESULT";
                                                                    value: import("./types").Hypothesis[];
                                                                }, undefined, import("./types").ASREvent>];
                                                                readonly target: ".Match";
                                                            };
                                                            readonly RECOGNISED: readonly [{
                                                                readonly target: ".NLURequest";
                                                                readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, {
                                                                    type: "RECOGNISED";
                                                                }>) => boolean;
                                                            }, {
                                                                readonly target: "Ready";
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "RECOGNISED";
                                                                }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                            }];
                                                            readonly CONTROL: {
                                                                readonly target: "Paused";
                                                            };
                                                            readonly STOP: {
                                                                readonly target: "Ready";
                                                            };
                                                            readonly NOINPUT: {
                                                                readonly actions: import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                    type: "NOINPUT";
                                                                }, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                                                readonly target: "Ready";
                                                            };
                                                        };
                                                        readonly states: {
                                                            readonly WaitForRecogniser: {
                                                                readonly on: {
                                                                    readonly STARTED: {
                                                                        readonly target: "NoInput";
                                                                        readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                            getToken: {
                                                                                src: "getToken";
                                                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            ponyfill: {
                                                                                src: "ponyfill";
                                                                                logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            recStart: {
                                                                                src: "recStart";
                                                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                            nluPromise: {
                                                                                src: "nluPromise";
                                                                                logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                                    query: string;
                                                                                }, import("xstate").EventObject>;
                                                                                id: string;
                                                                            };
                                                                        }>, never, never, never, never>, import("xstate").ActionFunction<import("./types").ASRContext, {
                                                                            type: "STARTED";
                                                                            value: {
                                                                                wsaASRinstance: import("./types").MySpeechRecognition;
                                                                            };
                                                                        }, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                    };
                                                                };
                                                            };
                                                            readonly NoInput: {
                                                                readonly entry: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                readonly on: {
                                                                    readonly STARTSPEECH: {
                                                                        readonly target: "InProgress";
                                                                        readonly actions: import("xstate").CancelAction<import("./types").ASRContext, {
                                                                            type: "STARTSPEECH";
                                                                        }, undefined, import("./types").ASREvent>;
                                                                    };
                                                                };
                                                                readonly exit: readonly [import("xstate").CancelAction<import("./types").ASRContext, import("./types").ASREvent, undefined, import("./types").ASREvent>];
                                                            };
                                                            readonly InProgress: {
                                                                readonly entry: () => void;
                                                            };
                                                            readonly Match: {
                                                                readonly entry: readonly [({ context }: import("xstate").ActionArgs<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                            };
                                                            readonly NLURequest: {
                                                                readonly invoke: {
                                                                    readonly src: "nluPromise";
                                                                    readonly input: ({ context }: {
                                                                        context: import("./types").ASRContext;
                                                                        event: import("./types").ASREvent;
                                                                        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                                    }) => {
                                                                        endpoint: string;
                                                                        key: string;
                                                                        projectName: string;
                                                                        deploymentName: string;
                                                                        query: string;
                                                                    };
                                                                    readonly onDone: readonly [{
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                        readonly target: "#asr.Ready";
                                                                        readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                                                                    }, {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<any, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                        readonly target: "#asr.Ready";
                                                                    }];
                                                                    readonly onError: {
                                                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void, import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent, undefined, never, never, never, never, never>];
                                                                        readonly target: "#asr.Ready";
                                                                    };
                                                                };
                                                            };
                                                        };
                                                    };
                                                    readonly Paused: {
                                                        readonly entry: import("xstate").ActionFunction<import("./types").ASRContext, import("./types").ASREvent, import("./types").ASREvent, undefined, never, never, never, never, never>;
                                                        readonly on: {
                                                            readonly CONTROL: {
                                                                readonly target: "Recognising";
                                                            };
                                                        };
                                                    };
                                                    readonly GetToken: {
                                                        readonly invoke: {
                                                            readonly id: "getAuthorizationToken";
                                                            readonly input: ({ context }: {
                                                                context: any;
                                                            }) => {
                                                                credentials: any;
                                                            };
                                                            readonly src: "getToken";
                                                            readonly onDone: {
                                                                readonly target: "Ponyfill";
                                                                readonly actions: readonly [import("xstate").ActionFunction<import("./types").ASRContext, import("xstate").DoneActorEvent<string, string>, import("./types").ASREvent, undefined, import("xstate").Values<{
                                                                    getToken: {
                                                                        src: "getToken";
                                                                        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    ponyfill: {
                                                                        src: "ponyfill";
                                                                        logic: import("xstate").CallbackActorLogic<null, import("./types").ASRPonyfillInput, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    recStart: {
                                                                        src: "recStart";
                                                                        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                    nluPromise: {
                                                                        src: "nluPromise";
                                                                        logic: import("xstate").PromiseActorLogic<any, import("./types").AzureLanguageCredentials & {
                                                                            query: string;
                                                                        }, import("xstate").EventObject>;
                                                                        id: string;
                                                                    };
                                                                }>, never, never, never, never>];
                                                            };
                                                            readonly onError: {
                                                                readonly actions: ({ event }: import("xstate").ActionArgs<import("./types").ASRContext, import("xstate").ErrorActorEvent<unknown, string>, import("./types").ASREvent>) => void;
                                                                readonly target: "Fail";
                                                            };
                                                        };
                                                    };
                                                    readonly Ponyfill: {
                                                        readonly invoke: {
                                                            readonly id: "ponyASR";
                                                            readonly src: "ponyfill";
                                                            readonly input: ({ context }: {
                                                                context: import("./types").ASRContext;
                                                                event: import("./types").ASREvent;
                                                                self: import("xstate").ActorRef<import("xstate").MachineSnapshot<import("./types").ASRContext, import("./types").ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, import("./types").ASREvent, import("xstate").AnyEventObject>;
                                                            }) => {
                                                                azureRegion: string;
                                                                audioContext: AudioContext;
                                                                azureAuthorizationToken: string;
                                                                locale: string;
                                                                speechRecognitionEndpointId: string;
                                                            };
                                                        };
                                                    };
                                                };
                                            }>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                            };
                        };
                    };
                };
                readonly AsrTtsManager: {
                    readonly initial: "Initialize";
                    readonly on: {
                        readonly TTS_READY: {
                            readonly actions: () => void;
                            readonly target: ".PreReady";
                        };
                        readonly ASR_READY: {
                            readonly actions: () => void;
                            readonly target: ".PreReady";
                        };
                        readonly TTS_ERROR: {
                            readonly actions: () => void;
                            readonly target: ".Fail";
                        };
                        readonly ASR_NOINPUT: {
                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                type: "ASR_NOINPUT";
                            }, SpeechStateEvent, undefined, never, never, never, never, never>];
                            readonly target: ".Ready";
                        };
                        readonly STOP: "#speechstate.Stopped";
                    };
                    readonly states: {
                        readonly Initialize: {
                            readonly meta: {
                                readonly view: "not-ready";
                            };
                        };
                        readonly PreReady: {
                            readonly meta: {
                                readonly view: "not-ready";
                            };
                            readonly on: {
                                readonly TTS_READY: {
                                    readonly actions: () => void;
                                    readonly target: "Ready";
                                };
                                readonly ASR_READY: {
                                    readonly actions: () => void;
                                    readonly target: "Ready";
                                };
                            };
                        };
                        readonly Ready: {
                            readonly initial: "Idle";
                            readonly entry: readonly [() => void, import("xstate").ActionFunction<SSContext, SpeechStateEvent, SpeechStateEvent, undefined, never, never, never, never, never>];
                            readonly states: {
                                readonly Idle: {
                                    readonly meta: {
                                        readonly view: "idle";
                                    };
                                    readonly on: {
                                        readonly LISTEN: {
                                            readonly target: "WaitForRecogniser";
                                        };
                                        readonly SPEAK: readonly [{
                                            readonly target: "Speaking";
                                        }];
                                    };
                                };
                                readonly Speaking: {
                                    readonly initial: "Proceed";
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => void, ({ context, event }: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => any];
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "#speechstate.Stopped";
                                            readonly actions: readonly [({}: import("xstate").ActionArgs<SSContext, {
                                                type: "STOP";
                                            }, SpeechStateEvent>) => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                type: "STOP";
                                            }, SpeechStateEvent>) => any];
                                        };
                                        readonly TTS_STARTED: {
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                                type: "TTS_STARTED";
                                            }, SpeechStateEvent, undefined, never, never, never, never, never>];
                                        };
                                        readonly SPEAK_COMPLETE: {
                                            readonly target: "Idle";
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, SpeechStateEvent, undefined, never, never, never, never, never>];
                                        };
                                        readonly STREAMING_SET_PERSONA: {
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                                type: "STREAMING_SET_PERSONA";
                                                value: string;
                                            }, SpeechStateEvent, undefined, never, never, never, never, never>];
                                        };
                                    };
                                    readonly states: {
                                        readonly Proceed: {
                                            readonly meta: {
                                                readonly view: "speaking";
                                            };
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Paused";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                        readonly Paused: {
                                            readonly meta: {
                                                readonly view: "speaking-paused";
                                            };
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Proceed";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                    };
                                };
                                readonly WaitForRecogniser: {
                                    readonly meta: {
                                        readonly view: "idle";
                                    };
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => void, ({ context, event }: import("xstate").ActionArgs<SSContext, SpeechStateEvent, SpeechStateEvent>) => any];
                                    readonly on: {
                                        readonly ASR_STARTED: {
                                            readonly target: "Recognising";
                                            readonly actions: readonly [() => void, import("xstate").ActionFunction<SSContext, {
                                                type: "ASR_STARTED";
                                            }, SpeechStateEvent, undefined, never, never, never, never, never>];
                                        };
                                    };
                                };
                                readonly Recognising: {
                                    readonly initial: "Proceed";
                                    readonly on: {
                                        readonly STOP: {
                                            readonly target: "#speechstate.Stopped";
                                            readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                type: "STOP";
                                            }, SpeechStateEvent>) => any];
                                        };
                                        readonly RECOGNISED: {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<SSContext, {
                                                type: "RECOGNISED";
                                                value: import("./types").Hypothesis[];
                                                nluValue?: any;
                                            }, SpeechStateEvent>) => void, import("xstate").ActionFunction<SSContext, {
                                                type: "RECOGNISED";
                                                value: import("./types").Hypothesis[];
                                                nluValue?: any;
                                            }, SpeechStateEvent, undefined, never, never, never, never, never>];
                                            readonly target: "Idle";
                                        };
                                    };
                                    readonly states: {
                                        readonly Proceed: {
                                            readonly meta: {
                                                readonly view: "recognising";
                                            };
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Paused";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                        readonly Paused: {
                                            readonly meta: {
                                                readonly view: "recognising-paused";
                                            };
                                            readonly on: {
                                                readonly CONTROL: {
                                                    readonly target: "Proceed";
                                                    readonly actions: readonly [() => void, ({ context }: import("xstate").ActionArgs<SSContext, {
                                                        type: "CONTROL";
                                                    }, SpeechStateEvent>) => any];
                                                };
                                            };
                                        };
                                    };
                                };
                            };
                        };
                        readonly Fail: {
                            readonly meta: {
                                readonly view: "error";
                            };
                        };
                        readonly Stopped: {
                            readonly meta: {
                                readonly view: "stopped";
                            };
                        };
                    };
                };
            };
        };
    };
}>;
export { speechstate };
//# sourceMappingURL=speechstate.d.ts.map