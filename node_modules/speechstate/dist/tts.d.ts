import { Agenda, TTSInit, TTSEvent, TTSContext, TTSPonyfillInput } from "./types";
export declare const ttsMachine: import("xstate").StateMachine<TTSContext, TTSEvent, {
    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>>;
}, import("xstate").Values<{
    getToken: {
        src: "getToken";
        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
        id: string;
    };
    createEventsFromStream: {
        src: "createEventsFromStream";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
        id: string;
    };
    ponyfill: {
        src: "ponyfill";
        logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
        id: string;
    };
    start: {
        src: "start";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
        id: string;
    };
}>, import("xstate").Values<{
    ttsStop: {
        type: "ttsStop";
        params: unknown;
    };
    addFiller: {
        type: "addFiller";
        params: {};
    };
    assignCurrentVoice: {
        type: "assignCurrentVoice";
        params: {};
    };
    sendParentCurrentPersona: {
        type: "sendParentCurrentPersona";
        params: {};
    };
}>, import("xstate").Values<{
    bufferContainsUtterancePartReadyToBeSpoken: {
        type: "bufferContainsUtterancePartReadyToBeSpoken";
        params: unknown;
    };
    bufferIsNonEmpty: {
        type: "bufferIsNonEmpty";
        params: unknown;
    };
}>, "FILLER_DELAY", "GetToken" | "Fail" | "Ponyfill" | {
    Ready?: "Idle" | {
        BufferedSpeaker?: Required<{
            Buffer?: "BufferIdle" | "Buffering" | "BufferingDone";
            Speaker?: "SpeakingIdle" | "PrepareSpeech" | {
                Speak?: "Go" | "Paused";
            };
        }>;
        Speaking?: "Go" | "Paused";
    };
}, string, TTSInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
    readonly id: "tts";
    readonly context: ({ input }: {
        spawn: {
            <TSrc extends "getToken" | "createEventsFromStream" | "ponyfill" | "start">(logic: TSrc, ...[options]: ({
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            } extends infer T ? T extends {
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            } ? T extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T["logic"]>;
                syncSnapshot?: boolean;
            } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                src: "createEventsFromStream";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                id: string;
            } extends infer T_1 ? T_1 extends {
                src: "createEventsFromStream";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                id: string;
            } ? T_1 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_1["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_1["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                id: string;
            } extends infer T_2 ? T_2 extends {
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                id: string;
            } ? T_2 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_2["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_2["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                src: "start";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                id: string;
            } extends infer T_3 ? T_3 extends {
                src: "start";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                id: string;
            } ? T_3 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_3["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_3["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                getToken: {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                };
                createEventsFromStream: {
                    src: "createEventsFromStream";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                    id: string;
                };
                ponyfill: {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                    id: string;
                };
                start: {
                    src: "start";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                    id: string;
                };
            }>, "src", TSrc>["logic"]>;
            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                id?: never;
                systemId?: string;
                input?: import("xstate").InputFrom<TLogic>;
                syncSnapshot?: boolean;
            }): import("xstate").ActorRefFromLogic<TLogic>;
        };
        input: TTSInit;
        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
    }) => {
        ttsDefaultVoice: string;
        ttsLexicon: string;
        audioContext: AudioContext;
        azureCredentials: string | import("./types").AzureSpeechCredentials;
        azureRegion: string;
        buffer: string;
    };
    readonly initial: "GetToken";
    readonly on: {
        readonly READY: {
            readonly target: ".Ready";
            readonly actions: readonly [import("xstate").ActionFunction<TTSContext, {
                type: "READY";
                value: {
                    wsaTTS: SpeechSynthesis;
                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                };
            }, TTSEvent, undefined, import("xstate").Values<{
                getToken: {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                };
                createEventsFromStream: {
                    src: "createEventsFromStream";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                    id: string;
                };
                ponyfill: {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                    id: string;
                };
                start: {
                    src: "start";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                    id: string;
                };
            }>, never, never, never, never>, import("xstate").ActionFunction<TTSContext, {
                type: "READY";
                value: {
                    wsaTTS: SpeechSynthesis;
                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                };
            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
        };
        readonly ERROR: {
            readonly actions: import("xstate").ActionFunction<TTSContext, {
                type: "ERROR";
            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
        };
    };
    readonly states: {
        readonly Ready: {
            readonly initial: "Idle";
            readonly states: {
                readonly Idle: {
                    readonly on: {
                        readonly SPEAK: readonly [{
                            readonly target: "BufferedSpeaker";
                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, {
                                type: "SPEAK";
                                value: Agenda;
                            }>) => boolean;
                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                type: "SPEAK";
                                value: Agenda;
                            }, TTSEvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                        }, {
                            readonly target: "Speaking";
                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                type: "SPEAK";
                                value: Agenda;
                            }, TTSEvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                createEventsFromStream: {
                                    src: "createEventsFromStream";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                start: {
                                    src: "start";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>;
                        }];
                    };
                };
                readonly BufferedSpeaker: {
                    readonly type: "parallel";
                    readonly invoke: {
                        readonly id: "createEventsFromStream";
                        readonly src: "createEventsFromStream";
                        readonly input: ({ context }: {
                            context: TTSContext;
                            event: TTSEvent;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                        }) => Agenda;
                    };
                    readonly on: {
                        readonly STOP: {
                            readonly target: "Idle";
                        };
                        readonly SPEAK_COMPLETE: readonly [{
                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<TTSContext, {
                                type: "SPEAK_COMPLETE";
                            }, undefined, any>;
                            readonly target: "Idle";
                            readonly actions: readonly [import("xstate").ActionFunction<TTSContext, {
                                type: "SPEAK_COMPLETE";
                            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>];
                        }];
                    };
                    readonly states: {
                        readonly Buffer: {
                            readonly initial: "BufferIdle";
                            readonly on: {
                                readonly STREAMING_SET_VOICE: {
                                    readonly actions: "assignCurrentVoice";
                                };
                                readonly STREAMING_SET_PERSONA: {
                                    readonly actions: "sendParentCurrentPersona";
                                };
                            };
                            readonly states: {
                                readonly BufferIdle: {
                                    readonly id: "BufferIdle";
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void];
                                    readonly on: {
                                        readonly STREAMING_CHUNK: {
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<TTSContext, {
                                                type: "STREAMING_CHUNK";
                                                value: string;
                                            }, TTSEvent>) => void];
                                            readonly target: "Buffering";
                                        };
                                    };
                                };
                                readonly Buffering: {
                                    readonly id: "Buffering";
                                    readonly on: {
                                        readonly STREAMING_CHUNK: readonly [{
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<TTSContext, {
                                                type: "STREAMING_CHUNK";
                                                value: string;
                                            }, TTSEvent>) => void];
                                            readonly target: "Buffering";
                                            readonly reenter: true;
                                        }];
                                        readonly STREAMING_DONE: readonly [{
                                            readonly target: "BufferingDone";
                                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<TTSContext, {
                                                type: "STREAMING_DONE";
                                            }, TTSEvent>) => void];
                                        }];
                                    };
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void, import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                };
                                readonly BufferingDone: {
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void];
                                    readonly id: "BufferingDone";
                                };
                            };
                        };
                        readonly Speaker: {
                            readonly initial: "SpeakingIdle";
                            readonly states: {
                                readonly SpeakingIdle: {
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void];
                                    readonly always: readonly [{
                                        readonly target: "Speak";
                                        readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<TTSContext, TTSEvent, undefined, any>;
                                        readonly actions: readonly [({ event }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void, import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>, import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                            getToken: {
                                                src: "getToken";
                                                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            createEventsFromStream: {
                                                src: "createEventsFromStream";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            ponyfill: {
                                                src: "ponyfill";
                                                logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                                id: string;
                                            };
                                            start: {
                                                src: "start";
                                                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                                id: string;
                                            };
                                        }>, never, never, never, never>];
                                    }, {
                                        readonly target: "PrepareSpeech";
                                        readonly guard: "bufferContainsUtterancePartReadyToBeSpoken";
                                    }];
                                    readonly after: {
                                        readonly FILLER_DELAY: {
                                            readonly target: "SpeakingIdle";
                                            readonly reenter: true;
                                            readonly actions: "addFiller";
                                            readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<TTSContext, TTSEvent>) => boolean;
                                        };
                                    };
                                };
                                readonly PrepareSpeech: {
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void, import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, import("xstate").Values<{
                                        getToken: {
                                            src: "getToken";
                                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        createEventsFromStream: {
                                            src: "createEventsFromStream";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        ponyfill: {
                                            src: "ponyfill";
                                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                                            id: string;
                                        };
                                        start: {
                                            src: "start";
                                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                                            id: string;
                                        };
                                    }>, never, never, never, never>];
                                    readonly always: readonly [{
                                        readonly target: "Speak";
                                    }];
                                };
                                readonly Speak: {
                                    readonly entry: readonly [({ event }: import("xstate").ActionArgs<TTSContext, TTSEvent, TTSEvent>) => void];
                                    readonly initial: "Go";
                                    readonly on: {
                                        readonly TTS_STARTED: {
                                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                                type: "TTS_STARTED";
                                            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                                        };
                                        readonly SPEAK_COMPLETE: readonly [{
                                            readonly guard: import("xstate/dist/declarations/src/guards").GuardPredicate<TTSContext, {
                                                type: "SPEAK_COMPLETE";
                                            }, undefined, any>;
                                            readonly target: "SpeakingIdle";
                                        }, {
                                            readonly guard: "bufferIsNonEmpty";
                                            readonly target: "SpeakingIdle";
                                        }];
                                    };
                                    readonly states: {
                                        readonly Go: {
                                            readonly invoke: {
                                                readonly src: "start";
                                                readonly input: ({ context }: {
                                                    context: TTSContext;
                                                    event: TTSEvent;
                                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                                }) => {
                                                    wsaTTS: SpeechSynthesis;
                                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                                    ttsLexicon: string;
                                                    voice: string;
                                                    utterance: string;
                                                };
                                            };
                                            readonly on: {
                                                readonly CONTROL: "Paused";
                                            };
                                            readonly exit: "ttsStop";
                                        };
                                        readonly Paused: {
                                            readonly on: {
                                                readonly CONTROL: "Go";
                                            };
                                        };
                                    };
                                };
                            };
                        };
                    };
                };
                readonly Speaking: {
                    readonly initial: "Go";
                    readonly on: {
                        readonly STOP: {
                            readonly target: "Idle";
                        };
                        readonly TTS_STARTED: {
                            readonly actions: import("xstate").ActionFunction<TTSContext, {
                                type: "TTS_STARTED";
                            }, TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                        };
                        readonly SPEAK_COMPLETE: {
                            readonly target: "Idle";
                        };
                    };
                    readonly exit: import("xstate").ActionFunction<TTSContext, TTSEvent, TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>;
                    readonly states: {
                        readonly Go: {
                            readonly invoke: {
                                readonly src: "start";
                                readonly input: ({ context }: {
                                    context: TTSContext;
                                    event: TTSEvent;
                                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                                }) => {
                                    wsaTTS: SpeechSynthesis;
                                    wsaUtt: import("./types").MySpeechSynthesisUtterance;
                                    ttsLexicon: string;
                                    voice: string;
                                    utterance: string;
                                };
                            };
                            readonly on: {
                                readonly CONTROL: "Paused";
                            };
                            readonly exit: "ttsStop";
                        };
                        readonly Paused: {
                            readonly on: {
                                readonly CONTROL: "Go";
                            };
                        };
                    };
                };
            };
        };
        readonly Fail: {};
        readonly GetToken: {
            readonly invoke: {
                readonly id: "getAuthorizationToken";
                readonly input: ({ context }: {
                    context: any;
                }) => {
                    credentials: any;
                };
                readonly src: "getToken";
                readonly onDone: {
                    readonly target: "Ponyfill";
                    readonly actions: readonly [import("xstate").ActionFunction<TTSContext, import("xstate").DoneActorEvent<string, string>, TTSEvent, undefined, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        createEventsFromStream: {
                            src: "createEventsFromStream";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, Agenda, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, TTSPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        start: {
                            src: "start";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, {}, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>];
                };
                readonly onError: {
                    readonly actions: readonly [import("xstate").ActionFunction<TTSContext, import("xstate").ErrorActorEvent<unknown, string>, TTSEvent, undefined, never, never, never, "FILLER_DELAY", never>, ({ event }: import("xstate").ActionArgs<TTSContext, import("xstate").ErrorActorEvent<unknown, string>, TTSEvent>) => void];
                    readonly target: "Fail";
                };
            };
        };
        readonly Ponyfill: {
            readonly invoke: {
                readonly id: "ponyTTS";
                readonly src: "ponyfill";
                readonly input: ({ context }: {
                    context: TTSContext;
                    event: TTSEvent;
                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<TTSContext, TTSEvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, TTSEvent, import("xstate").AnyEventObject>;
                }) => {
                    audioContext: AudioContext;
                    azureAuthorizationToken: string;
                    azureRegion: string;
                };
            };
        };
    };
}>;
//# sourceMappingURL=tts.d.ts.map