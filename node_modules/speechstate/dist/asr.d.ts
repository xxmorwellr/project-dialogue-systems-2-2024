import { ASRContext, ASREvent, ASRInit, ASRPonyfillInput, Hypothesis, AzureLanguageCredentials } from "./types";
export declare const asrMachine: import("xstate").StateMachine<ASRContext, ASREvent, {
    [x: string]: import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>> | import("xstate").ActorRefFromLogic<import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
        query: string;
    }, import("xstate").EventObject>>;
}, import("xstate").Values<{
    getToken: {
        src: "getToken";
        logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
        id: string;
    };
    ponyfill: {
        src: "ponyfill";
        logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
        id: string;
    };
    recStart: {
        src: "recStart";
        logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
        id: string;
    };
    nluPromise: {
        src: "nluPromise";
        logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
            query: string;
        }, import("xstate").EventObject>;
        id: string;
    };
}>, {
    type: "recStop";
    params: unknown;
}, never, never, "GetToken" | "Ready" | "Paused" | "Fail" | "Ponyfill" | {
    Recognising?: "WaitForRecogniser" | "NoInput" | "InProgress" | "Match" | "NLURequest";
}, string, ASRInit, {}, import("xstate").EventObject, import("xstate").MetaObject, {
    readonly id: "asr";
    readonly context: ({ input }: {
        spawn: {
            <TSrc extends "getToken" | "ponyfill" | "recStart" | "nluPromise">(logic: TSrc, ...[options]: ({
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            } extends infer T ? T extends {
                src: "getToken";
                logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                id: string;
            } ? T extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T["logic"]>;
                syncSnapshot?: boolean;
            } & { [K in import("xstate").RequiredActorOptions<T>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T>>> : never : never : never) | ({
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                id: string;
            } extends infer T_1 ? T_1 extends {
                src: "ponyfill";
                logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                id: string;
            } ? T_1 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_1["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_1["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_1 in import("xstate").RequiredActorOptions<T_1>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_1>>> : never : never : never) | ({
                src: "recStart";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                id: string;
            } extends infer T_2 ? T_2 extends {
                src: "recStart";
                logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                id: string;
            } ? T_2 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_2["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_2["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_2 in import("xstate").RequiredActorOptions<T_2>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_2>>> : never : never : never) | ({
                src: "nluPromise";
                logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                    query: string;
                }, import("xstate").EventObject>;
                id: string;
            } extends infer T_3 ? T_3 extends {
                src: "nluPromise";
                logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                    query: string;
                }, import("xstate").EventObject>;
                id: string;
            } ? T_3 extends {
                src: TSrc;
            } ? import("xstate").ConditionalRequired<[options?: {
                id?: T_3["id"];
                systemId?: string;
                input?: import("xstate").InputFrom<T_3["logic"]>;
                syncSnapshot?: boolean;
            } & { [K_3 in import("xstate").RequiredActorOptions<T_3>]: unknown; }], import("xstate").IsNotNever<import("xstate").RequiredActorOptions<T_3>>> : never : never : never)): import("xstate").ActorRefFromLogic<import("xstate").GetConcreteByKey<import("xstate").Values<{
                getToken: {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                };
                ponyfill: {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                };
                recStart: {
                    src: "recStart";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                    id: string;
                };
                nluPromise: {
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                        query: string;
                    }, import("xstate").EventObject>;
                    id: string;
                };
            }>, "src", TSrc>["logic"]>;
            <TLogic extends import("xstate").AnyActorLogic>(src: TLogic, options?: {
                id?: never;
                systemId?: string;
                input?: import("xstate").InputFrom<TLogic>;
                syncSnapshot?: boolean;
            }): import("xstate").ActorRefFromLogic<TLogic>;
        };
        input: ASRInit;
        self: import("xstate").ActorRef<import("xstate").MachineSnapshot<ASRContext, ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, ASREvent, import("xstate").AnyEventObject>;
    }) => {
        asrDefaultCompleteTimeout: number;
        asrDefaultNoInputTimeout: number;
        locale: string;
        audioContext: AudioContext;
        azureCredentials: string | import("./types").AzureSpeechCredentials;
        azureRegion: string;
        azureLanguageCredentials: AzureLanguageCredentials;
        speechRecognitionEndpointId: string;
    };
    readonly initial: "GetToken";
    readonly on: {
        readonly READY: {
            readonly target: ".Ready";
            readonly actions: readonly [import("xstate").ActionFunction<ASRContext, {
                type: "READY";
                value: {
                    wsaASR: import("./types").MySpeechRecognition;
                    wsaGrammarList: import("./types").MySpeechGrammarList;
                };
            }, ASREvent, undefined, import("xstate").Values<{
                getToken: {
                    src: "getToken";
                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                    id: string;
                };
                ponyfill: {
                    src: "ponyfill";
                    logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                    id: string;
                };
                recStart: {
                    src: "recStart";
                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                    id: string;
                };
                nluPromise: {
                    src: "nluPromise";
                    logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                        query: string;
                    }, import("xstate").EventObject>;
                    id: string;
                };
            }>, never, never, never, never>, import("xstate").ActionFunction<ASRContext, {
                type: "READY";
                value: {
                    wsaASR: import("./types").MySpeechRecognition;
                    wsaGrammarList: import("./types").MySpeechGrammarList;
                };
            }, ASREvent, undefined, never, never, never, never, never>];
        };
    };
    readonly states: {
        readonly Fail: {};
        readonly Ready: {
            readonly on: {
                readonly START: {
                    readonly target: "Recognising";
                    readonly actions: import("xstate").ActionFunction<ASRContext, {
                        type: "START";
                        value?: import("./types").RecogniseParameters;
                    }, ASREvent, undefined, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        recStart: {
                            src: "recStart";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                                query: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>;
                };
            };
        };
        readonly Recognising: {
            readonly initial: "WaitForRecogniser";
            readonly invoke: {
                readonly id: "recStart";
                readonly input: ({ context }: {
                    context: any;
                }) => {
                    wsaASR: any;
                    wsaGrammarList: any;
                    locale: any;
                    phrases: any;
                };
                readonly src: "recStart";
            };
            readonly exit: "recStop";
            readonly on: {
                readonly RESULT: {
                    readonly actions: readonly [import("xstate").ActionFunction<ASRContext, {
                        type: "RESULT";
                        value: Hypothesis[];
                    }, ASREvent, undefined, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        recStart: {
                            src: "recStart";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                                query: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>, import("xstate").CancelAction<ASRContext, {
                        type: "RESULT";
                        value: Hypothesis[];
                    }, undefined, ASREvent>];
                    readonly target: ".Match";
                };
                readonly RECOGNISED: readonly [{
                    readonly target: ".NLURequest";
                    readonly guard: ({ context }: import("xstate/dist/declarations/src/guards").GuardArgs<ASRContext, {
                        type: "RECOGNISED";
                    }>) => boolean;
                }, {
                    readonly target: "Ready";
                    readonly actions: readonly [import("xstate").ActionFunction<ASRContext, {
                        type: "RECOGNISED";
                    }, ASREvent, undefined, never, never, never, never, never>];
                }];
                readonly CONTROL: {
                    readonly target: "Paused";
                };
                readonly STOP: {
                    readonly target: "Ready";
                };
                readonly NOINPUT: {
                    readonly actions: import("xstate").ActionFunction<ASRContext, {
                        type: "NOINPUT";
                    }, ASREvent, undefined, never, never, never, never, never>;
                    readonly target: "Ready";
                };
            };
            readonly states: {
                readonly WaitForRecogniser: {
                    readonly on: {
                        readonly STARTED: {
                            readonly target: "NoInput";
                            readonly actions: readonly [import("xstate").ActionFunction<ASRContext, {
                                type: "STARTED";
                                value: {
                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                };
                            }, ASREvent, undefined, import("xstate").Values<{
                                getToken: {
                                    src: "getToken";
                                    logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                ponyfill: {
                                    src: "ponyfill";
                                    logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                                    id: string;
                                };
                                recStart: {
                                    src: "recStart";
                                    logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                                    id: string;
                                };
                                nluPromise: {
                                    src: "nluPromise";
                                    logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                                        query: string;
                                    }, import("xstate").EventObject>;
                                    id: string;
                                };
                            }>, never, never, never, never>, import("xstate").ActionFunction<ASRContext, {
                                type: "STARTED";
                                value: {
                                    wsaASRinstance: import("./types").MySpeechRecognition;
                                };
                            }, ASREvent, undefined, never, never, never, never, never>];
                        };
                    };
                };
                readonly NoInput: {
                    readonly entry: readonly [import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, never, never>];
                    readonly on: {
                        readonly STARTSPEECH: {
                            readonly target: "InProgress";
                            readonly actions: import("xstate").CancelAction<ASRContext, {
                                type: "STARTSPEECH";
                            }, undefined, ASREvent>;
                        };
                    };
                    readonly exit: readonly [import("xstate").CancelAction<ASRContext, ASREvent, undefined, ASREvent>];
                };
                readonly InProgress: {
                    readonly entry: () => void;
                };
                readonly Match: {
                    readonly entry: readonly [({ context }: import("xstate").ActionArgs<ASRContext, ASREvent, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, never, never>];
                };
                readonly NLURequest: {
                    readonly invoke: {
                        readonly src: "nluPromise";
                        readonly input: ({ context }: {
                            context: ASRContext;
                            event: ASREvent;
                            self: import("xstate").ActorRef<import("xstate").MachineSnapshot<ASRContext, ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, ASREvent, import("xstate").AnyEventObject>;
                        }) => {
                            endpoint: string;
                            key: string;
                            projectName: string;
                            deploymentName: string;
                            query: string;
                        };
                        readonly onDone: readonly [{
                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent, undefined, never, never, never, never, never>];
                            readonly target: "#asr.Ready";
                            readonly guard: ({ event }: import("xstate/dist/declarations/src/guards").GuardArgs<ASRContext, import("xstate").DoneActorEvent<any, string>>) => boolean;
                        }, {
                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, import("xstate").DoneActorEvent<any, string>, ASREvent, undefined, never, never, never, never, never>];
                            readonly target: "#asr.Ready";
                        }];
                        readonly onError: {
                            readonly actions: readonly [({ event }: import("xstate").ActionArgs<ASRContext, import("xstate").ErrorActorEvent<unknown, string>, ASREvent>) => void, import("xstate").ActionFunction<ASRContext, import("xstate").ErrorActorEvent<unknown, string>, ASREvent, undefined, never, never, never, never, never>];
                            readonly target: "#asr.Ready";
                        };
                    };
                };
            };
        };
        readonly Paused: {
            readonly entry: import("xstate").ActionFunction<ASRContext, ASREvent, ASREvent, undefined, never, never, never, never, never>;
            readonly on: {
                readonly CONTROL: {
                    readonly target: "Recognising";
                };
            };
        };
        readonly GetToken: {
            readonly invoke: {
                readonly id: "getAuthorizationToken";
                readonly input: ({ context }: {
                    context: any;
                }) => {
                    credentials: any;
                };
                readonly src: "getToken";
                readonly onDone: {
                    readonly target: "Ponyfill";
                    readonly actions: readonly [import("xstate").ActionFunction<ASRContext, import("xstate").DoneActorEvent<string, string>, ASREvent, undefined, import("xstate").Values<{
                        getToken: {
                            src: "getToken";
                            logic: import("xstate").PromiseActorLogic<string, any, import("xstate").EventObject>;
                            id: string;
                        };
                        ponyfill: {
                            src: "ponyfill";
                            logic: import("xstate").CallbackActorLogic<null, ASRPonyfillInput, import("xstate").EventObject>;
                            id: string;
                        };
                        recStart: {
                            src: "recStart";
                            logic: import("xstate").CallbackActorLogic<import("xstate").EventObject, any, import("xstate").EventObject>;
                            id: string;
                        };
                        nluPromise: {
                            src: "nluPromise";
                            logic: import("xstate").PromiseActorLogic<any, AzureLanguageCredentials & {
                                query: string;
                            }, import("xstate").EventObject>;
                            id: string;
                        };
                    }>, never, never, never, never>];
                };
                readonly onError: {
                    readonly actions: ({ event }: import("xstate").ActionArgs<ASRContext, import("xstate").ErrorActorEvent<unknown, string>, ASREvent>) => void;
                    readonly target: "Fail";
                };
            };
        };
        readonly Ponyfill: {
            readonly invoke: {
                readonly id: "ponyASR";
                readonly src: "ponyfill";
                readonly input: ({ context }: {
                    context: ASRContext;
                    event: ASREvent;
                    self: import("xstate").ActorRef<import("xstate").MachineSnapshot<ASRContext, ASREvent, Record<string, import("xstate").AnyActorRef>, import("xstate").StateValue, string, unknown, any, any>, ASREvent, import("xstate").AnyEventObject>;
                }) => {
                    azureRegion: string;
                    audioContext: AudioContext;
                    azureAuthorizationToken: string;
                    locale: string;
                    speechRecognitionEndpointId: string;
                };
            };
        };
    };
}>;
//# sourceMappingURL=asr.d.ts.map