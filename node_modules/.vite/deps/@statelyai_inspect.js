import {
  require_commonjs_browser
} from "./chunk-BNOE2KXM.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  init_xstate_development_esm,
  xstate_development_esm_exports
} from "./chunk-XR5AD7XK.js";

// node_modules/fast-safe-stringify/index.js
var require_fast_safe_stringify = __commonJS({
  "node_modules/fast-safe-stringify/index.js"(exports, module) {
    module.exports = stringify2;
    stringify2.default = stringify2;
    stringify2.stable = deterministicStringify;
    stringify2.stableStringify = deterministicStringify;
    var LIMIT_REPLACE_NODE = "[...]";
    var CIRCULAR_REPLACE_NODE = "[Circular]";
    var arr = [];
    var replacerStack = [];
    function defaultOptions() {
      return {
        depthLimit: Number.MAX_SAFE_INTEGER,
        edgesLimit: Number.MAX_SAFE_INTEGER
      };
    }
    function stringify2(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      decirc(obj, "", 0, [], void 0, 0, options);
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(obj, replacer, spacer);
        } else {
          res = JSON.stringify(obj, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function setReplace(replace, val, k, parent) {
      var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k);
      if (propertyDescriptor.get !== void 0) {
        if (propertyDescriptor.configurable) {
          Object.defineProperty(parent, k, { value: replace });
          arr.push([parent, k, val, propertyDescriptor]);
        } else {
          replacerStack.push([val, k, replace]);
        }
      } else {
        parent[k] = replace;
        arr.push([parent, k, val]);
      }
    }
    function decirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            decirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var keys = Object.keys(val);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            decirc(val[key], key, i, stack, val, depth, options);
          }
        }
        stack.pop();
      }
    }
    function compareFunction(a, b) {
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    function deterministicStringify(obj, replacer, spacer, options) {
      if (typeof options === "undefined") {
        options = defaultOptions();
      }
      var tmp = deterministicDecirc(obj, "", 0, [], void 0, 0, options) || obj;
      var res;
      try {
        if (replacerStack.length === 0) {
          res = JSON.stringify(tmp, replacer, spacer);
        } else {
          res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer);
        }
      } catch (_) {
        return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
      } finally {
        while (arr.length !== 0) {
          var part = arr.pop();
          if (part.length === 4) {
            Object.defineProperty(part[0], part[1], part[3]);
          } else {
            part[0][part[1]] = part[2];
          }
        }
      }
      return res;
    }
    function deterministicDecirc(val, k, edgeIndex, stack, parent, depth, options) {
      depth += 1;
      var i;
      if (typeof val === "object" && val !== null) {
        for (i = 0; i < stack.length; i++) {
          if (stack[i] === val) {
            setReplace(CIRCULAR_REPLACE_NODE, val, k, parent);
            return;
          }
        }
        try {
          if (typeof val.toJSON === "function") {
            return;
          }
        } catch (_) {
          return;
        }
        if (typeof options.depthLimit !== "undefined" && depth > options.depthLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        if (typeof options.edgesLimit !== "undefined" && edgeIndex + 1 > options.edgesLimit) {
          setReplace(LIMIT_REPLACE_NODE, val, k, parent);
          return;
        }
        stack.push(val);
        if (Array.isArray(val)) {
          for (i = 0; i < val.length; i++) {
            deterministicDecirc(val[i], i, i, stack, val, depth, options);
          }
        } else {
          var tmp = {};
          var keys = Object.keys(val).sort(compareFunction);
          for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            deterministicDecirc(val[key], key, i, stack, val, depth, options);
            tmp[key] = val[key];
          }
          if (typeof parent !== "undefined") {
            arr.push([parent, k, val]);
            parent[k] = tmp;
          } else {
            return tmp;
          }
        }
        stack.pop();
      }
    }
    function replaceGetterValues(replacer) {
      replacer = typeof replacer !== "undefined" ? replacer : function(k, v) {
        return v;
      };
      return function(key, val) {
        if (replacerStack.length > 0) {
          for (var i = 0; i < replacerStack.length; i++) {
            var part = replacerStack[i];
            if (part[1] === key && part[0] === val) {
              val = part[2];
              replacerStack.splice(i, 1);
              break;
            }
          }
        }
        return replacer.call(this, key, val);
      };
    }
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports, module) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify2 = configure();
    stringify2.configure = configure;
    stringify2.stringify = stringify2;
    stringify2.default = stringify2;
    exports.stringify = stringify2;
    exports.configure = configure;
    module.exports = stringify2;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(
        Object.getPrototypeOf(
          new Int8Array()
        )
      ),
      Symbol.toStringTag
    ).get;
    function isTypedArrayWithEntries(value) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value) !== void 0 && value.length !== 0;
    }
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    function getDeterministicOption(options) {
      let value;
      if (hasOwnProperty.call(options, "deterministic")) {
        value = options.deterministic;
        if (typeof value !== "boolean" && typeof value !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value === void 0 ? true : value;
    }
    function getBooleanOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value === void 0 ? true : value;
    }
    function getPositiveIntegerOption(options, key) {
      let value;
      if (hasOwnProperty.call(options, key)) {
        value = options[key];
        if (typeof value !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value === void 0 ? Infinity : value;
    }
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value of replacerArray) {
        if (typeof value === "string" || typeof value === "number") {
          replacerSet.add(String(value));
        }
      }
      return replacerSet;
    }
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value = options.strict;
        if (typeof value !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value) {
          return (value2) => {
            let message = `Object can not safely be stringified. Received type ${typeof value2}`;
            if (typeof value2 !== "function") message += ` (${value2.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    function configure(options) {
      options = { ...options };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value = parent[key];
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        value = replacer.call(parent, key, value);
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value)) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyArrayReplacer(key, value, stack, replacer, spacer, indentation) {
        if (typeof value === "object" && value !== null && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifyIndent(key, value, stack, spacer, indentation) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifyIndent(key, value, stack, spacer, indentation);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, join, maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringifySimple(key, value, stack) {
        switch (typeof value) {
          case "string":
            return strEscape(value);
          case "object": {
            if (value === null) {
              return "null";
            }
            if (typeof value.toJSON === "function") {
              value = value.toJSON(key);
              if (typeof value !== "object") {
                return stringifySimple(key, value, stack);
              }
              if (value === null) {
                return "null";
              }
            }
            if (stack.indexOf(value) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value.length !== void 0;
            if (hasLength && Array.isArray(value)) {
              if (value.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value);
              const maximumValuesToStringify = Math.min(value.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value.length - 1 > maximumBreadth) {
                const removedKeys = value.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value)) {
              res += stringifyTypedArray(value, ",", maximumBreadth);
              keys = keys.slice(value.length);
              maximumPropertiesToStringify -= value.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value) ? String(value) : fail ? fail(value) : "null";
          case "boolean":
            return value === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value);
            }
          default:
            return fail ? fail(value) : void 0;
        }
      }
      function stringify3(value, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", { "": value }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value, [], spacer, "");
          }
        }
        return stringifySimple("", value, []);
      }
      return stringify3;
    }
  }
});

// node_modules/partysocket/dist/index.js
var require_dist = __commonJS({
  "node_modules/partysocket/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      WebSocket: () => ReconnectingWebSocket,
      default: () => PartySocket
    });
    module.exports = __toCommonJS2(src_exports);
    if (!globalThis.EventTarget || !globalThis.Event) {
      console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
    }
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        __publicField(this, "message");
        __publicField(this, "error");
        this.message = error.message;
        this.error = error;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code = 1e3, reason = "", target) {
        super("close", target);
        __publicField(this, "code");
        __publicField(this, "reason");
        __publicField(this, "wasClean", true);
        this.code = code;
        this.reason = reason;
      }
    };
    var Events = {
      Event,
      ErrorEvent,
      CloseEvent
    };
    function assert(condition, msg) {
      if (!condition) {
        throw new Error(msg);
      }
    }
    function cloneEventBrowser(e) {
      return new e.constructor(e.type, e);
    }
    function cloneEventNode(e) {
      if ("data" in e) {
        const evt2 = new MessageEvent(e.type, e);
        return evt2;
      }
      if ("code" in e || "reason" in e) {
        const evt2 = new CloseEvent(
          // @ts-expect-error we need to fix event/listener types
          e.code || 1999,
          // @ts-expect-error we need to fix event/listener types
          e.reason || "unknown reason",
          e
        );
        return evt2;
      }
      if ("error" in e) {
        const evt2 = new ErrorEvent(e.error, e);
        return evt2;
      }
      const evt = new Event(e.type, e);
      return evt;
    }
    var _a;
    var isNode = typeof process !== "undefined" && typeof ((_a = process.versions) == null ? void 0 : _a.node) !== "undefined" && typeof document === "undefined";
    var cloneEvent = isNode ? cloneEventNode : cloneEventBrowser;
    var DEFAULT = {
      maxReconnectionDelay: 1e4,
      minReconnectionDelay: 1e3 + Math.random() * 4e3,
      minUptime: 5e3,
      reconnectionDelayGrowFactor: 1.3,
      connectionTimeout: 4e3,
      maxRetries: Infinity,
      maxEnqueuedMessages: Infinity,
      startClosed: false,
      debug: false
    };
    var didWarnAboutMissingWebSocket = false;
    var ReconnectingWebSocket = class _ReconnectingWebSocket extends EventTarget {
      constructor(url, protocols, options = {}) {
        super();
        __publicField(this, "_ws");
        __publicField(this, "_retryCount", -1);
        __publicField(this, "_uptimeTimeout");
        __publicField(this, "_connectTimeout");
        __publicField(this, "_shouldReconnect", true);
        __publicField(this, "_connectLock", false);
        __publicField(this, "_binaryType", "blob");
        __publicField(this, "_closeCalled", false);
        __publicField(this, "_messageQueue", []);
        __publicField(this, "_debugLogger", console.log.bind(console));
        __publicField(this, "_url");
        __publicField(this, "_protocols");
        __publicField(this, "_options");
        /**
         * An event listener to be called when the WebSocket connection's readyState changes to CLOSED
         */
        __publicField(this, "onclose", null);
        /**
         * An event listener to be called when an error occurs
         */
        __publicField(this, "onerror", null);
        /**
         * An event listener to be called when a message is received from the server
         */
        __publicField(this, "onmessage", null);
        /**
         * An event listener to be called when the WebSocket connection's readyState changes to OPEN;
         * this indicates that the connection is ready to send and receive data
         */
        __publicField(this, "onopen", null);
        __publicField(this, "_handleOpen", (event) => {
          this._debug("open event");
          const { minUptime = DEFAULT.minUptime } = this._options;
          clearTimeout(this._connectTimeout);
          this._uptimeTimeout = setTimeout(() => this._acceptOpen(), minUptime);
          assert(this._ws, "WebSocket is not defined");
          this._ws.binaryType = this._binaryType;
          this._messageQueue.forEach((message) => {
            var _a2;
            return (_a2 = this._ws) == null ? void 0 : _a2.send(message);
          });
          this._messageQueue = [];
          if (this.onopen) {
            this.onopen(event);
          }
          this.dispatchEvent(cloneEvent(event));
        });
        __publicField(this, "_handleMessage", (event) => {
          this._debug("message event");
          if (this.onmessage) {
            this.onmessage(event);
          }
          this.dispatchEvent(cloneEvent(event));
        });
        __publicField(this, "_handleError", (event) => {
          this._debug("error event", event.message);
          this._disconnect(
            void 0,
            event.message === "TIMEOUT" ? "timeout" : void 0
          );
          if (this.onerror) {
            this.onerror(event);
          }
          this._debug("exec error listeners");
          this.dispatchEvent(cloneEvent(event));
          this._connect();
        });
        __publicField(this, "_handleClose", (event) => {
          this._debug("close event");
          this._clearTimeouts();
          if (this._shouldReconnect) {
            this._connect();
          }
          if (this.onclose) {
            this.onclose(event);
          }
          this.dispatchEvent(cloneEvent(event));
        });
        this._url = url;
        this._protocols = protocols;
        this._options = options;
        if (this._options.startClosed) {
          this._shouldReconnect = false;
        }
        if (this._options.debugLogger) {
          this._debugLogger = this._options.debugLogger;
        }
        this._connect();
      }
      static get CONNECTING() {
        return 0;
      }
      static get OPEN() {
        return 1;
      }
      static get CLOSING() {
        return 2;
      }
      static get CLOSED() {
        return 3;
      }
      get CONNECTING() {
        return _ReconnectingWebSocket.CONNECTING;
      }
      get OPEN() {
        return _ReconnectingWebSocket.OPEN;
      }
      get CLOSING() {
        return _ReconnectingWebSocket.CLOSING;
      }
      get CLOSED() {
        return _ReconnectingWebSocket.CLOSED;
      }
      get binaryType() {
        return this._ws ? this._ws.binaryType : this._binaryType;
      }
      set binaryType(value) {
        this._binaryType = value;
        if (this._ws) {
          this._ws.binaryType = value;
        }
      }
      /**
       * Returns the number or connection retries
       */
      get retryCount() {
        return Math.max(this._retryCount, 0);
      }
      /**
       * The number of bytes of data that have been queued using calls to send() but not yet
       * transmitted to the network. This value resets to zero once all queued data has been sent.
       * This value does not reset to zero when the connection is closed; if you keep calling send(),
       * this will continue to climb. Read only
       */
      get bufferedAmount() {
        const bytes = this._messageQueue.reduce((acc, message) => {
          if (typeof message === "string") {
            acc += message.length;
          } else if (message instanceof Blob) {
            acc += message.size;
          } else {
            acc += message.byteLength;
          }
          return acc;
        }, 0);
        return bytes + (this._ws ? this._ws.bufferedAmount : 0);
      }
      /**
       * The extensions selected by the server. This is currently only the empty string or a list of
       * extensions as negotiated by the connection
       */
      get extensions() {
        return this._ws ? this._ws.extensions : "";
      }
      /**
       * A string indicating the name of the sub-protocol the server selected;
       * this will be one of the strings specified in the protocols parameter when creating the
       * WebSocket object
       */
      get protocol() {
        return this._ws ? this._ws.protocol : "";
      }
      /**
       * The current state of the connection; this is one of the Ready state constants
       */
      get readyState() {
        if (this._ws) {
          return this._ws.readyState;
        }
        return this._options.startClosed ? _ReconnectingWebSocket.CLOSED : _ReconnectingWebSocket.CONNECTING;
      }
      /**
       * The URL as resolved by the constructor
       */
      get url() {
        return this._ws ? this._ws.url : "";
      }
      /**
       * Whether the websocket object is now in reconnectable state
       */
      get shouldReconnect() {
        return this._shouldReconnect;
      }
      /**
       * Closes the WebSocket connection or connection attempt, if any. If the connection is already
       * CLOSED, this method does nothing
       */
      close(code = 1e3, reason) {
        this._closeCalled = true;
        this._shouldReconnect = false;
        this._clearTimeouts();
        if (!this._ws) {
          this._debug("close enqueued: no ws instance");
          return;
        }
        if (this._ws.readyState === this.CLOSED) {
          this._debug("close: already closed");
          return;
        }
        this._ws.close(code, reason);
      }
      /**
       * Closes the WebSocket connection or connection attempt and connects again.
       * Resets retry counter;
       */
      reconnect(code, reason) {
        this._shouldReconnect = true;
        this._closeCalled = false;
        this._retryCount = -1;
        if (!this._ws || this._ws.readyState === this.CLOSED) {
          this._connect();
        } else {
          this._disconnect(code, reason);
          this._connect();
        }
      }
      /**
       * Enqueue specified data to be transmitted to the server over the WebSocket connection
       */
      send(data) {
        if (this._ws && this._ws.readyState === this.OPEN) {
          this._debug("send", data);
          this._ws.send(data);
        } else {
          const { maxEnqueuedMessages = DEFAULT.maxEnqueuedMessages } = this._options;
          if (this._messageQueue.length < maxEnqueuedMessages) {
            this._debug("enqueue", data);
            this._messageQueue.push(data);
          }
        }
      }
      _debug(...args) {
        if (this._options.debug) {
          this._debugLogger("RWS>", ...args);
        }
      }
      _getNextDelay() {
        const {
          reconnectionDelayGrowFactor = DEFAULT.reconnectionDelayGrowFactor,
          minReconnectionDelay = DEFAULT.minReconnectionDelay,
          maxReconnectionDelay = DEFAULT.maxReconnectionDelay
        } = this._options;
        let delay = 0;
        if (this._retryCount > 0) {
          delay = minReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, this._retryCount - 1);
          if (delay > maxReconnectionDelay) {
            delay = maxReconnectionDelay;
          }
        }
        this._debug("next delay", delay);
        return delay;
      }
      _wait() {
        return new Promise((resolve) => {
          setTimeout(resolve, this._getNextDelay());
        });
      }
      _getNextProtocols(protocolsProvider) {
        if (!protocolsProvider)
          return Promise.resolve(null);
        if (typeof protocolsProvider === "string" || Array.isArray(protocolsProvider)) {
          return Promise.resolve(protocolsProvider);
        }
        if (typeof protocolsProvider === "function") {
          const protocols = protocolsProvider();
          if (!protocols)
            return Promise.resolve(null);
          if (typeof protocols === "string" || Array.isArray(protocols)) {
            return Promise.resolve(protocols);
          }
          if (protocols.then) {
            return protocols;
          }
        }
        throw Error("Invalid protocols");
      }
      _getNextUrl(urlProvider) {
        if (typeof urlProvider === "string") {
          return Promise.resolve(urlProvider);
        }
        if (typeof urlProvider === "function") {
          const url = urlProvider();
          if (typeof url === "string") {
            return Promise.resolve(url);
          }
          if (url.then) {
            return url;
          }
        }
        throw Error("Invalid URL");
      }
      _connect() {
        if (this._connectLock || !this._shouldReconnect) {
          return;
        }
        this._connectLock = true;
        const {
          maxRetries = DEFAULT.maxRetries,
          connectionTimeout = DEFAULT.connectionTimeout
        } = this._options;
        if (this._retryCount >= maxRetries) {
          this._debug("max retries reached", this._retryCount, ">=", maxRetries);
          return;
        }
        this._retryCount++;
        this._debug("connect", this._retryCount);
        this._removeListeners();
        this._wait().then(
          () => Promise.all([
            this._getNextUrl(this._url),
            this._getNextProtocols(this._protocols || null)
          ])
        ).then(([url, protocols]) => {
          if (this._closeCalled) {
            this._connectLock = false;
            return;
          }
          if (!this._options.WebSocket && typeof WebSocket === "undefined" && !didWarnAboutMissingWebSocket) {
            console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`);
            didWarnAboutMissingWebSocket = true;
          }
          const WS = this._options.WebSocket || WebSocket;
          this._debug("connect", { url, protocols });
          this._ws = protocols ? new WS(url, protocols) : new WS(url);
          this._ws.binaryType = this._binaryType;
          this._connectLock = false;
          this._addListeners();
          this._connectTimeout = setTimeout(
            () => this._handleTimeout(),
            connectionTimeout
          );
        }).catch((err) => {
          this._connectLock = false;
          this._handleError(new Events.ErrorEvent(Error(err.message), this));
        });
      }
      _handleTimeout() {
        this._debug("timeout event");
        this._handleError(new Events.ErrorEvent(Error("TIMEOUT"), this));
      }
      _disconnect(code = 1e3, reason) {
        this._clearTimeouts();
        if (!this._ws) {
          return;
        }
        this._removeListeners();
        try {
          this._ws.close(code, reason);
          this._handleClose(new Events.CloseEvent(code, reason, this));
        } catch (error) {
        }
      }
      _acceptOpen() {
        this._debug("accept open");
        this._retryCount = 0;
      }
      _removeListeners() {
        if (!this._ws) {
          return;
        }
        this._debug("removeListeners");
        this._ws.removeEventListener("open", this._handleOpen);
        this._ws.removeEventListener("close", this._handleClose);
        this._ws.removeEventListener("message", this._handleMessage);
        this._ws.removeEventListener("error", this._handleError);
      }
      _addListeners() {
        if (!this._ws) {
          return;
        }
        this._debug("addListeners");
        this._ws.addEventListener("open", this._handleOpen);
        this._ws.addEventListener("close", this._handleClose);
        this._ws.addEventListener("message", this._handleMessage);
        this._ws.addEventListener("error", this._handleError);
      }
      _clearTimeouts() {
        clearTimeout(this._connectTimeout);
        clearTimeout(this._uptimeTimeout);
      }
    };
    var valueIsNotNil = (keyValuePair) => keyValuePair[1] !== null && keyValuePair[1] !== void 0;
    function generateUUID() {
      if (typeof crypto !== "undefined" && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      let d = (/* @__PURE__ */ new Date()).getTime();
      let d2 = typeof performance !== "undefined" && performance.now && performance.now() * 1e3 || 0;
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        let r = Math.random() * 16;
        if (d > 0) {
          r = (d + r) % 16 | 0;
          d = Math.floor(d / 16);
        } else {
          r = (d2 + r) % 16 | 0;
          d2 = Math.floor(d2 / 16);
        }
        return (c === "x" ? r : r & 3 | 8).toString(16);
      });
    }
    function getPartyInfo(partySocketOptions, defaultProtocol, defaultParams = {}) {
      const {
        host: rawHost,
        path: rawPath,
        protocol: rawProtocol,
        room,
        party,
        query
      } = partySocketOptions;
      let host = rawHost.replace(/^(http|https|ws|wss):\/\//, "");
      if (host.endsWith("/")) {
        host = host.slice(0, -1);
      }
      if (rawPath && rawPath.startsWith("/")) {
        throw new Error("path must not start with a slash");
      }
      const name = party ?? "main";
      const path = rawPath ? `/${rawPath}` : "";
      const protocol = rawProtocol || (host.startsWith("localhost:") || host.startsWith("127.0.0.1:") || host.startsWith("192.168.") || host.startsWith("10.") || host.startsWith("172.") && host.split(".")[1] >= "16" && host.split(".")[1] <= "31" || host.startsWith("[::ffff:7f00:1]:") ? (
        // http / ws
        defaultProtocol
      ) : (
        // https / wss
        defaultProtocol + "s"
      ));
      const baseUrl = `${protocol}://${host}/${party ? `parties/${party}` : "party"}/${room}${path}`;
      const makeUrl = (query2 = {}) => `${baseUrl}?${new URLSearchParams([
        ...Object.entries(defaultParams),
        ...Object.entries(query2).filter(valueIsNotNil)
      ])}`;
      const urlProvider = typeof query === "function" ? async () => makeUrl(await query()) : makeUrl(query);
      return {
        host,
        path,
        room,
        name,
        protocol,
        partyUrl: baseUrl,
        urlProvider
      };
    }
    var PartySocket = class extends ReconnectingWebSocket {
      constructor(partySocketOptions) {
        const wsOptions = getWSOptions(partySocketOptions);
        super(wsOptions.urlProvider, wsOptions.protocols, wsOptions.socketOptions);
        __publicField(this, "_pk");
        __publicField(this, "_pkurl");
        __publicField(this, "name");
        __publicField(this, "room");
        __publicField(this, "host");
        __publicField(this, "path");
        this.partySocketOptions = partySocketOptions;
        this.setWSProperties(wsOptions);
      }
      updateProperties(partySocketOptions) {
        const wsOptions = getWSOptions({
          ...this.partySocketOptions,
          ...partySocketOptions,
          host: partySocketOptions.host ?? this.host,
          room: partySocketOptions.room ?? this.room,
          path: partySocketOptions.path ?? this.path
        });
        this._url = wsOptions.urlProvider;
        this._protocols = wsOptions.protocols;
        this._options = wsOptions.socketOptions;
        this.setWSProperties(wsOptions);
      }
      setWSProperties(wsOptions) {
        const { _pk, _pkurl, name, room, host, path } = wsOptions;
        this._pk = _pk;
        this._pkurl = _pkurl;
        this.name = name;
        this.room = room;
        this.host = host;
        this.path = path;
      }
      reconnect(code, reason) {
        if (!this.room || !this.host) {
          throw new Error(
            "The room and host must be set before connecting, use `updateProperties` method to set them or pass them to the constructor."
          );
        }
        super.reconnect(code, reason);
      }
      get id() {
        return this._pk;
      }
      /**
       * Exposes the static PartyKit room URL without applying query parameters.
       * To access the currently connected WebSocket url, use PartySocket#url.
       */
      get roomUrl() {
        return this._pkurl;
      }
      // a `fetch` method that uses (almost) the same options as `PartySocket`
      static async fetch(options, init) {
        const party = getPartyInfo(options, "http");
        const url = typeof party.urlProvider === "string" ? party.urlProvider : await party.urlProvider();
        const doFetch = options.fetch ?? fetch;
        return doFetch(url, init);
      }
    };
    function getWSOptions(partySocketOptions) {
      const {
        id,
        host: _host,
        path: _path,
        party: _party,
        room: _room,
        protocol: _protocol,
        query: _query,
        protocols,
        ...socketOptions
      } = partySocketOptions;
      const _pk = id || generateUUID();
      const party = getPartyInfo(partySocketOptions, "ws", { _pk });
      return {
        _pk,
        _pkurl: party.partyUrl,
        name: party.name,
        room: party.room,
        host: party.host,
        path: party.path,
        protocols,
        socketOptions,
        urlProvider: party.urlProvider
      };
    }
  }
});

// node_modules/superjson/dist/esm/double-indexed-kv.js
var DoubleIndexedKV;
var init_double_indexed_kv = __esm({
  "node_modules/superjson/dist/esm/double-indexed-kv.js"() {
    DoubleIndexedKV = /** @class */
    function() {
      function DoubleIndexedKV2() {
        this.keyToValue = /* @__PURE__ */ new Map();
        this.valueToKey = /* @__PURE__ */ new Map();
      }
      DoubleIndexedKV2.prototype.set = function(key, value) {
        this.keyToValue.set(key, value);
        this.valueToKey.set(value, key);
      };
      DoubleIndexedKV2.prototype.getByKey = function(key) {
        return this.keyToValue.get(key);
      };
      DoubleIndexedKV2.prototype.getByValue = function(value) {
        return this.valueToKey.get(value);
      };
      DoubleIndexedKV2.prototype.clear = function() {
        this.keyToValue.clear();
        this.valueToKey.clear();
      };
      return DoubleIndexedKV2;
    }();
  }
});

// node_modules/superjson/dist/esm/registry.js
var Registry;
var init_registry = __esm({
  "node_modules/superjson/dist/esm/registry.js"() {
    init_double_indexed_kv();
    Registry = /** @class */
    function() {
      function Registry2(generateIdentifier) {
        this.generateIdentifier = generateIdentifier;
        this.kv = new DoubleIndexedKV();
      }
      Registry2.prototype.register = function(value, identifier) {
        if (this.kv.getByValue(value)) {
          return;
        }
        if (!identifier) {
          identifier = this.generateIdentifier(value);
        }
        this.kv.set(identifier, value);
      };
      Registry2.prototype.clear = function() {
        this.kv.clear();
      };
      Registry2.prototype.getIdentifier = function(value) {
        return this.kv.getByValue(value);
      };
      Registry2.prototype.getValue = function(identifier) {
        return this.kv.getByKey(identifier);
      };
      return Registry2;
    }();
  }
});

// node_modules/superjson/dist/esm/class-registry.js
var __extends, ClassRegistry;
var init_class_registry = __esm({
  "node_modules/superjson/dist/esm/class-registry.js"() {
    init_registry();
    __extends = /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    ClassRegistry = /** @class */
    function(_super) {
      __extends(ClassRegistry2, _super);
      function ClassRegistry2() {
        var _this = _super.call(this, function(c) {
          return c.name;
        }) || this;
        _this.classToAllowedProps = /* @__PURE__ */ new Map();
        return _this;
      }
      ClassRegistry2.prototype.register = function(value, options) {
        if (typeof options === "object") {
          if (options.allowProps) {
            this.classToAllowedProps.set(value, options.allowProps);
          }
          _super.prototype.register.call(this, value, options.identifier);
        } else {
          _super.prototype.register.call(this, value, options);
        }
      };
      ClassRegistry2.prototype.getAllowedProps = function(value) {
        return this.classToAllowedProps.get(value);
      };
      return ClassRegistry2;
    }(Registry);
  }
});

// node_modules/superjson/dist/esm/util.js
function valuesOfObj(record) {
  if ("values" in Object) {
    return Object.values(record);
  }
  var values = [];
  for (var key in record) {
    if (record.hasOwnProperty(key)) {
      values.push(record[key]);
    }
  }
  return values;
}
function find(record, predicate) {
  var values = valuesOfObj(record);
  if ("find" in values) {
    return values.find(predicate);
  }
  var valuesNotNever = values;
  for (var i = 0; i < valuesNotNever.length; i++) {
    var value = valuesNotNever[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
function forEach(record, run) {
  Object.entries(record).forEach(function(_a) {
    var _b = __read(_a, 2), key = _b[0], value = _b[1];
    return run(value, key);
  });
}
function includes(arr, value) {
  return arr.indexOf(value) !== -1;
}
function findArr(record, predicate) {
  for (var i = 0; i < record.length; i++) {
    var value = record[i];
    if (predicate(value)) {
      return value;
    }
  }
  return void 0;
}
var __read;
var init_util = __esm({
  "node_modules/superjson/dist/esm/util.js"() {
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
  }
});

// node_modules/superjson/dist/esm/custom-transformer-registry.js
var CustomTransformerRegistry;
var init_custom_transformer_registry = __esm({
  "node_modules/superjson/dist/esm/custom-transformer-registry.js"() {
    init_util();
    CustomTransformerRegistry = /** @class */
    function() {
      function CustomTransformerRegistry2() {
        this.transfomers = {};
      }
      CustomTransformerRegistry2.prototype.register = function(transformer) {
        this.transfomers[transformer.name] = transformer;
      };
      CustomTransformerRegistry2.prototype.findApplicable = function(v) {
        return find(this.transfomers, function(transformer) {
          return transformer.isApplicable(v);
        });
      };
      CustomTransformerRegistry2.prototype.findByName = function(name) {
        return this.transfomers[name];
      };
      return CustomTransformerRegistry2;
    }();
  }
});

// node_modules/superjson/dist/esm/is.js
var getType, isUndefined, isNull, isPlainObject, isEmptyObject, isArray, isString, isNumber, isBoolean, isRegExp, isMap, isSet, isSymbol, isDate, isError, isNaNValue, isPrimitive, isBigint, isInfinite, isTypedArray, isURL;
var init_is = __esm({
  "node_modules/superjson/dist/esm/is.js"() {
    getType = function(payload) {
      return Object.prototype.toString.call(payload).slice(8, -1);
    };
    isUndefined = function(payload) {
      return typeof payload === "undefined";
    };
    isNull = function(payload) {
      return payload === null;
    };
    isPlainObject = function(payload) {
      if (typeof payload !== "object" || payload === null)
        return false;
      if (payload === Object.prototype)
        return false;
      if (Object.getPrototypeOf(payload) === null)
        return true;
      return Object.getPrototypeOf(payload) === Object.prototype;
    };
    isEmptyObject = function(payload) {
      return isPlainObject(payload) && Object.keys(payload).length === 0;
    };
    isArray = function(payload) {
      return Array.isArray(payload);
    };
    isString = function(payload) {
      return typeof payload === "string";
    };
    isNumber = function(payload) {
      return typeof payload === "number" && !isNaN(payload);
    };
    isBoolean = function(payload) {
      return typeof payload === "boolean";
    };
    isRegExp = function(payload) {
      return payload instanceof RegExp;
    };
    isMap = function(payload) {
      return payload instanceof Map;
    };
    isSet = function(payload) {
      return payload instanceof Set;
    };
    isSymbol = function(payload) {
      return getType(payload) === "Symbol";
    };
    isDate = function(payload) {
      return payload instanceof Date && !isNaN(payload.valueOf());
    };
    isError = function(payload) {
      return payload instanceof Error;
    };
    isNaNValue = function(payload) {
      return typeof payload === "number" && isNaN(payload);
    };
    isPrimitive = function(payload) {
      return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);
    };
    isBigint = function(payload) {
      return typeof payload === "bigint";
    };
    isInfinite = function(payload) {
      return payload === Infinity || payload === -Infinity;
    };
    isTypedArray = function(payload) {
      return ArrayBuffer.isView(payload) && !(payload instanceof DataView);
    };
    isURL = function(payload) {
      return payload instanceof URL;
    };
  }
});

// node_modules/superjson/dist/esm/pathstringifier.js
var escapeKey, stringifyPath, parsePath;
var init_pathstringifier = __esm({
  "node_modules/superjson/dist/esm/pathstringifier.js"() {
    escapeKey = function(key) {
      return key.replace(/\./g, "\\.");
    };
    stringifyPath = function(path) {
      return path.map(String).map(escapeKey).join(".");
    };
    parsePath = function(string) {
      var result = [];
      var segment = "";
      for (var i = 0; i < string.length; i++) {
        var char = string.charAt(i);
        var isEscapedDot = char === "\\" && string.charAt(i + 1) === ".";
        if (isEscapedDot) {
          segment += ".";
          i++;
          continue;
        }
        var isEndOfSegment = char === ".";
        if (isEndOfSegment) {
          result.push(segment);
          segment = "";
          continue;
        }
        segment += char;
      }
      var lastSegment = segment;
      result.push(lastSegment);
      return result;
    };
  }
});

// node_modules/superjson/dist/esm/transformer.js
function simpleTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
function compositeTransformation(isApplicable, annotation, transform, untransform) {
  return {
    isApplicable,
    annotation,
    transform,
    untransform
  };
}
function isInstanceOfRegisteredClass(potentialClass, superJson) {
  if (potentialClass === null || potentialClass === void 0 ? void 0 : potentialClass.constructor) {
    var isRegistered = !!superJson.classRegistry.getIdentifier(potentialClass.constructor);
    return isRegistered;
  }
  return false;
}
var __assign, __read2, __spreadArray, simpleRules, symbolRule, constructorToName, typedArrayRule, classRule, customRule, compositeRules, transformValue, simpleRulesByAnnotation, untransformValue;
var init_transformer = __esm({
  "node_modules/superjson/dist/esm/transformer.js"() {
    init_is();
    init_util();
    __assign = function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    simpleRules = [
      simpleTransformation(isUndefined, "undefined", function() {
        return null;
      }, function() {
        return void 0;
      }),
      simpleTransformation(isBigint, "bigint", function(v) {
        return v.toString();
      }, function(v) {
        if (typeof BigInt !== "undefined") {
          return BigInt(v);
        }
        console.error("Please add a BigInt polyfill.");
        return v;
      }),
      simpleTransformation(isDate, "Date", function(v) {
        return v.toISOString();
      }, function(v) {
        return new Date(v);
      }),
      simpleTransformation(isError, "Error", function(v, superJson) {
        var baseError = {
          name: v.name,
          message: v.message
        };
        superJson.allowedErrorProps.forEach(function(prop) {
          baseError[prop] = v[prop];
        });
        return baseError;
      }, function(v, superJson) {
        var e = new Error(v.message);
        e.name = v.name;
        e.stack = v.stack;
        superJson.allowedErrorProps.forEach(function(prop) {
          e[prop] = v[prop];
        });
        return e;
      }),
      simpleTransformation(isRegExp, "regexp", function(v) {
        return "" + v;
      }, function(regex) {
        var body = regex.slice(1, regex.lastIndexOf("/"));
        var flags = regex.slice(regex.lastIndexOf("/") + 1);
        return new RegExp(body, flags);
      }),
      simpleTransformation(
        isSet,
        "set",
        // (sets only exist in es6+)
        // eslint-disable-next-line es5/no-es6-methods
        function(v) {
          return __spreadArray([], __read2(v.values()));
        },
        function(v) {
          return new Set(v);
        }
      ),
      simpleTransformation(isMap, "map", function(v) {
        return __spreadArray([], __read2(v.entries()));
      }, function(v) {
        return new Map(v);
      }),
      simpleTransformation(function(v) {
        return isNaNValue(v) || isInfinite(v);
      }, "number", function(v) {
        if (isNaNValue(v)) {
          return "NaN";
        }
        if (v > 0) {
          return "Infinity";
        } else {
          return "-Infinity";
        }
      }, Number),
      simpleTransformation(function(v) {
        return v === 0 && 1 / v === -Infinity;
      }, "number", function() {
        return "-0";
      }, Number),
      simpleTransformation(isURL, "URL", function(v) {
        return v.toString();
      }, function(v) {
        return new URL(v);
      })
    ];
    symbolRule = compositeTransformation(function(s, superJson) {
      if (isSymbol(s)) {
        var isRegistered = !!superJson.symbolRegistry.getIdentifier(s);
        return isRegistered;
      }
      return false;
    }, function(s, superJson) {
      var identifier = superJson.symbolRegistry.getIdentifier(s);
      return ["symbol", identifier];
    }, function(v) {
      return v.description;
    }, function(_, a, superJson) {
      var value = superJson.symbolRegistry.getValue(a[1]);
      if (!value) {
        throw new Error("Trying to deserialize unknown symbol");
      }
      return value;
    });
    constructorToName = [
      Int8Array,
      Uint8Array,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array,
      Uint8ClampedArray
    ].reduce(function(obj, ctor) {
      obj[ctor.name] = ctor;
      return obj;
    }, {});
    typedArrayRule = compositeTransformation(isTypedArray, function(v) {
      return ["typed-array", v.constructor.name];
    }, function(v) {
      return __spreadArray([], __read2(v));
    }, function(v, a) {
      var ctor = constructorToName[a[1]];
      if (!ctor) {
        throw new Error("Trying to deserialize unknown typed array");
      }
      return new ctor(v);
    });
    classRule = compositeTransformation(isInstanceOfRegisteredClass, function(clazz, superJson) {
      var identifier = superJson.classRegistry.getIdentifier(clazz.constructor);
      return ["class", identifier];
    }, function(clazz, superJson) {
      var allowedProps = superJson.classRegistry.getAllowedProps(clazz.constructor);
      if (!allowedProps) {
        return __assign({}, clazz);
      }
      var result = {};
      allowedProps.forEach(function(prop) {
        result[prop] = clazz[prop];
      });
      return result;
    }, function(v, a, superJson) {
      var clazz = superJson.classRegistry.getValue(a[1]);
      if (!clazz) {
        throw new Error("Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564");
      }
      return Object.assign(Object.create(clazz.prototype), v);
    });
    customRule = compositeTransformation(function(value, superJson) {
      return !!superJson.customTransformerRegistry.findApplicable(value);
    }, function(value, superJson) {
      var transformer = superJson.customTransformerRegistry.findApplicable(value);
      return ["custom", transformer.name];
    }, function(value, superJson) {
      var transformer = superJson.customTransformerRegistry.findApplicable(value);
      return transformer.serialize(value);
    }, function(v, a, superJson) {
      var transformer = superJson.customTransformerRegistry.findByName(a[1]);
      if (!transformer) {
        throw new Error("Trying to deserialize unknown custom value");
      }
      return transformer.deserialize(v);
    });
    compositeRules = [classRule, symbolRule, customRule, typedArrayRule];
    transformValue = function(value, superJson) {
      var applicableCompositeRule = findArr(compositeRules, function(rule) {
        return rule.isApplicable(value, superJson);
      });
      if (applicableCompositeRule) {
        return {
          value: applicableCompositeRule.transform(value, superJson),
          type: applicableCompositeRule.annotation(value, superJson)
        };
      }
      var applicableSimpleRule = findArr(simpleRules, function(rule) {
        return rule.isApplicable(value, superJson);
      });
      if (applicableSimpleRule) {
        return {
          value: applicableSimpleRule.transform(value, superJson),
          type: applicableSimpleRule.annotation
        };
      }
      return void 0;
    };
    simpleRulesByAnnotation = {};
    simpleRules.forEach(function(rule) {
      simpleRulesByAnnotation[rule.annotation] = rule;
    });
    untransformValue = function(json, type, superJson) {
      if (isArray(type)) {
        switch (type[0]) {
          case "symbol":
            return symbolRule.untransform(json, type, superJson);
          case "class":
            return classRule.untransform(json, type, superJson);
          case "custom":
            return customRule.untransform(json, type, superJson);
          case "typed-array":
            return typedArrayRule.untransform(json, type, superJson);
          default:
            throw new Error("Unknown transformation: " + type);
        }
      } else {
        var transformation = simpleRulesByAnnotation[type];
        if (!transformation) {
          throw new Error("Unknown transformation: " + type);
        }
        return transformation.untransform(json, superJson);
      }
    };
  }
});

// node_modules/superjson/dist/esm/accessDeep.js
function validatePath(path) {
  if (includes(path, "__proto__")) {
    throw new Error("__proto__ is not allowed as a property");
  }
  if (includes(path, "prototype")) {
    throw new Error("prototype is not allowed as a property");
  }
  if (includes(path, "constructor")) {
    throw new Error("constructor is not allowed as a property");
  }
}
var getNthKey, getDeep, setDeep;
var init_accessDeep = __esm({
  "node_modules/superjson/dist/esm/accessDeep.js"() {
    init_is();
    init_util();
    getNthKey = function(value, n) {
      var keys = value.keys();
      while (n > 0) {
        keys.next();
        n--;
      }
      return keys.next().value;
    };
    getDeep = function(object, path) {
      validatePath(path);
      for (var i = 0; i < path.length; i++) {
        var key = path[i];
        if (isSet(object)) {
          object = getNthKey(object, +key);
        } else if (isMap(object)) {
          var row = +key;
          var type = +path[++i] === 0 ? "key" : "value";
          var keyOfRow = getNthKey(object, row);
          switch (type) {
            case "key":
              object = keyOfRow;
              break;
            case "value":
              object = object.get(keyOfRow);
              break;
          }
        } else {
          object = object[key];
        }
      }
      return object;
    };
    setDeep = function(object, path, mapper) {
      validatePath(path);
      if (path.length === 0) {
        return mapper(object);
      }
      var parent = object;
      for (var i = 0; i < path.length - 1; i++) {
        var key = path[i];
        if (isArray(parent)) {
          var index = +key;
          parent = parent[index];
        } else if (isPlainObject(parent)) {
          parent = parent[key];
        } else if (isSet(parent)) {
          var row = +key;
          parent = getNthKey(parent, row);
        } else if (isMap(parent)) {
          var isEnd = i === path.length - 2;
          if (isEnd) {
            break;
          }
          var row = +key;
          var type = +path[++i] === 0 ? "key" : "value";
          var keyOfRow = getNthKey(parent, row);
          switch (type) {
            case "key":
              parent = keyOfRow;
              break;
            case "value":
              parent = parent.get(keyOfRow);
              break;
          }
        }
      }
      var lastKey = path[path.length - 1];
      if (isArray(parent)) {
        parent[+lastKey] = mapper(parent[+lastKey]);
      } else if (isPlainObject(parent)) {
        parent[lastKey] = mapper(parent[lastKey]);
      }
      if (isSet(parent)) {
        var oldValue = getNthKey(parent, +lastKey);
        var newValue = mapper(oldValue);
        if (oldValue !== newValue) {
          parent["delete"](oldValue);
          parent.add(newValue);
        }
      }
      if (isMap(parent)) {
        var row = +path[path.length - 2];
        var keyToRow = getNthKey(parent, row);
        var type = +lastKey === 0 ? "key" : "value";
        switch (type) {
          case "key": {
            var newKey = mapper(keyToRow);
            parent.set(newKey, parent.get(keyToRow));
            if (newKey !== keyToRow) {
              parent["delete"](keyToRow);
            }
            break;
          }
          case "value": {
            parent.set(keyToRow, mapper(parent.get(keyToRow)));
            break;
          }
        }
      }
      return object;
    };
  }
});

// node_modules/superjson/dist/esm/plainer.js
function traverse(tree, walker2, origin) {
  if (origin === void 0) {
    origin = [];
  }
  if (!tree) {
    return;
  }
  if (!isArray(tree)) {
    forEach(tree, function(subtree, key) {
      return traverse(subtree, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
    return;
  }
  var _a = __read3(tree, 2), nodeValue = _a[0], children = _a[1];
  if (children) {
    forEach(children, function(child, key) {
      traverse(child, walker2, __spreadArray2(__spreadArray2([], __read3(origin)), __read3(parsePath(key))));
    });
  }
  walker2(nodeValue, origin);
}
function applyValueAnnotations(plain, annotations, superJson) {
  traverse(annotations, function(type, path) {
    plain = setDeep(plain, path, function(v) {
      return untransformValue(v, type, superJson);
    });
  });
  return plain;
}
function applyReferentialEqualityAnnotations(plain, annotations) {
  function apply(identicalPaths, path) {
    var object = getDeep(plain, parsePath(path));
    identicalPaths.map(parsePath).forEach(function(identicalObjectPath) {
      plain = setDeep(plain, identicalObjectPath, function() {
        return object;
      });
    });
  }
  if (isArray(annotations)) {
    var _a = __read3(annotations, 2), root = _a[0], other = _a[1];
    root.forEach(function(identicalPath) {
      plain = setDeep(plain, parsePath(identicalPath), function() {
        return plain;
      });
    });
    if (other) {
      forEach(other, apply);
    }
  } else {
    forEach(annotations, apply);
  }
  return plain;
}
function addIdentity(object, path, identities) {
  var existingSet = identities.get(object);
  if (existingSet) {
    existingSet.push(path);
  } else {
    identities.set(object, [path]);
  }
}
function generateReferentialEqualityAnnotations(identitites, dedupe) {
  var result = {};
  var rootEqualityPaths = void 0;
  identitites.forEach(function(paths) {
    if (paths.length <= 1) {
      return;
    }
    if (!dedupe) {
      paths = paths.map(function(path) {
        return path.map(String);
      }).sort(function(a, b) {
        return a.length - b.length;
      });
    }
    var _a = __read3(paths), representativePath = _a[0], identicalPaths = _a.slice(1);
    if (representativePath.length === 0) {
      rootEqualityPaths = identicalPaths.map(stringifyPath);
    } else {
      result[stringifyPath(representativePath)] = identicalPaths.map(stringifyPath);
    }
  });
  if (rootEqualityPaths) {
    if (isEmptyObject(result)) {
      return [rootEqualityPaths];
    } else {
      return [rootEqualityPaths, result];
    }
  } else {
    return isEmptyObject(result) ? void 0 : result;
  }
}
var __read3, __spreadArray2, isDeep, walker;
var init_plainer = __esm({
  "node_modules/superjson/dist/esm/plainer.js"() {
    init_is();
    init_pathstringifier();
    init_transformer();
    init_util();
    init_pathstringifier();
    init_accessDeep();
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    isDeep = function(object, superJson) {
      return isPlainObject(object) || isArray(object) || isMap(object) || isSet(object) || isInstanceOfRegisteredClass(object, superJson);
    };
    walker = function(object, identities, superJson, dedupe, path, objectsInThisPath, seenObjects) {
      var _a;
      if (path === void 0) {
        path = [];
      }
      if (objectsInThisPath === void 0) {
        objectsInThisPath = [];
      }
      if (seenObjects === void 0) {
        seenObjects = /* @__PURE__ */ new Map();
      }
      var primitive = isPrimitive(object);
      if (!primitive) {
        addIdentity(object, path, identities);
        var seen = seenObjects.get(object);
        if (seen) {
          return dedupe ? {
            transformedValue: null
          } : seen;
        }
      }
      if (!isDeep(object, superJson)) {
        var transformed_1 = transformValue(object, superJson);
        var result_1 = transformed_1 ? {
          transformedValue: transformed_1.value,
          annotations: [transformed_1.type]
        } : {
          transformedValue: object
        };
        if (!primitive) {
          seenObjects.set(object, result_1);
        }
        return result_1;
      }
      if (includes(objectsInThisPath, object)) {
        return {
          transformedValue: null
        };
      }
      var transformationResult = transformValue(object, superJson);
      var transformed = (_a = transformationResult === null || transformationResult === void 0 ? void 0 : transformationResult.value) !== null && _a !== void 0 ? _a : object;
      var transformedValue = isArray(transformed) ? [] : {};
      var innerAnnotations = {};
      forEach(transformed, function(value, index) {
        var recursiveResult = walker(value, identities, superJson, dedupe, __spreadArray2(__spreadArray2([], __read3(path)), [index]), __spreadArray2(__spreadArray2([], __read3(objectsInThisPath)), [object]), seenObjects);
        transformedValue[index] = recursiveResult.transformedValue;
        if (isArray(recursiveResult.annotations)) {
          innerAnnotations[index] = recursiveResult.annotations;
        } else if (isPlainObject(recursiveResult.annotations)) {
          forEach(recursiveResult.annotations, function(tree, key) {
            innerAnnotations[escapeKey(index) + "." + key] = tree;
          });
        }
      });
      var result = isEmptyObject(innerAnnotations) ? {
        transformedValue,
        annotations: !!transformationResult ? [transformationResult.type] : void 0
      } : {
        transformedValue,
        annotations: !!transformationResult ? [transformationResult.type, innerAnnotations] : innerAnnotations
      };
      if (!primitive) {
        seenObjects.set(object, result);
      }
      return result;
    };
  }
});

// node_modules/is-what/dist/index.js
function getType2(payload) {
  return Object.prototype.toString.call(payload).slice(8, -1);
}
function isArray2(payload) {
  return getType2(payload) === "Array";
}
function isPlainObject2(payload) {
  if (getType2(payload) !== "Object")
    return false;
  const prototype = Object.getPrototypeOf(payload);
  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;
}
function isNull2(payload) {
  return getType2(payload) === "Null";
}
function isOneOf(a, b, c, d, e) {
  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);
}
function isUndefined2(payload) {
  return getType2(payload) === "Undefined";
}
var isNullOrUndefined;
var init_dist = __esm({
  "node_modules/is-what/dist/index.js"() {
    isNullOrUndefined = isOneOf(isNull2, isUndefined2);
  }
});

// node_modules/copy-anything/dist/index.js
function assignProp(carry, key, newVal, originalObject, includeNonenumerable) {
  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? "enumerable" : "nonenumerable";
  if (propType === "enumerable")
    carry[key] = newVal;
  if (includeNonenumerable && propType === "nonenumerable") {
    Object.defineProperty(carry, key, {
      value: newVal,
      enumerable: false,
      writable: true,
      configurable: true
    });
  }
}
function copy(target, options = {}) {
  if (isArray2(target)) {
    return target.map((item) => copy(item, options));
  }
  if (!isPlainObject2(target)) {
    return target;
  }
  const props = Object.getOwnPropertyNames(target);
  const symbols = Object.getOwnPropertySymbols(target);
  return [...props, ...symbols].reduce((carry, key) => {
    if (isArray2(options.props) && !options.props.includes(key)) {
      return carry;
    }
    const val = target[key];
    const newVal = copy(val, options);
    assignProp(carry, key, newVal, target, options.nonenumerable);
    return carry;
  }, {});
}
var init_dist2 = __esm({
  "node_modules/copy-anything/dist/index.js"() {
    init_dist();
  }
});

// node_modules/superjson/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  SuperJSON: () => SuperJSON,
  allowErrorProps: () => allowErrorProps,
  default: () => esm_default,
  deserialize: () => deserialize,
  parse: () => parse,
  registerClass: () => registerClass,
  registerCustom: () => registerCustom,
  registerSymbol: () => registerSymbol,
  serialize: () => serialize,
  stringify: () => stringify
});
var __assign2, __read4, __spreadArray3, SuperJSON, esm_default, serialize, deserialize, stringify, parse, registerClass, registerCustom, registerSymbol, allowErrorProps;
var init_esm = __esm({
  "node_modules/superjson/dist/esm/index.js"() {
    init_class_registry();
    init_registry();
    init_custom_transformer_registry();
    init_plainer();
    init_dist2();
    __assign2 = function() {
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign2.apply(this, arguments);
    };
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
      return to;
    };
    SuperJSON = /** @class */
    function() {
      function SuperJSON2(_a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.dedupe, dedupe = _c === void 0 ? false : _c;
        this.classRegistry = new ClassRegistry();
        this.symbolRegistry = new Registry(function(s) {
          var _a2;
          return (_a2 = s.description) !== null && _a2 !== void 0 ? _a2 : "";
        });
        this.customTransformerRegistry = new CustomTransformerRegistry();
        this.allowedErrorProps = [];
        this.dedupe = dedupe;
      }
      SuperJSON2.prototype.serialize = function(object) {
        var identities = /* @__PURE__ */ new Map();
        var output = walker(object, identities, this, this.dedupe);
        var res = {
          json: output.transformedValue
        };
        if (output.annotations) {
          res.meta = __assign2(__assign2({}, res.meta), { values: output.annotations });
        }
        var equalityAnnotations = generateReferentialEqualityAnnotations(identities, this.dedupe);
        if (equalityAnnotations) {
          res.meta = __assign2(__assign2({}, res.meta), { referentialEqualities: equalityAnnotations });
        }
        return res;
      };
      SuperJSON2.prototype.deserialize = function(payload) {
        var json = payload.json, meta = payload.meta;
        var result = copy(json);
        if (meta === null || meta === void 0 ? void 0 : meta.values) {
          result = applyValueAnnotations(result, meta.values, this);
        }
        if (meta === null || meta === void 0 ? void 0 : meta.referentialEqualities) {
          result = applyReferentialEqualityAnnotations(result, meta.referentialEqualities);
        }
        return result;
      };
      SuperJSON2.prototype.stringify = function(object) {
        return JSON.stringify(this.serialize(object));
      };
      SuperJSON2.prototype.parse = function(string) {
        return this.deserialize(JSON.parse(string));
      };
      SuperJSON2.prototype.registerClass = function(v, options) {
        this.classRegistry.register(v, options);
      };
      SuperJSON2.prototype.registerSymbol = function(v, identifier) {
        this.symbolRegistry.register(v, identifier);
      };
      SuperJSON2.prototype.registerCustom = function(transformer, name) {
        this.customTransformerRegistry.register(__assign2({ name }, transformer));
      };
      SuperJSON2.prototype.allowErrorProps = function() {
        var _a;
        var props = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          props[_i] = arguments[_i];
        }
        (_a = this.allowedErrorProps).push.apply(_a, __spreadArray3([], __read4(props)));
      };
      SuperJSON2.defaultInstance = new SuperJSON2();
      SuperJSON2.serialize = SuperJSON2.defaultInstance.serialize.bind(SuperJSON2.defaultInstance);
      SuperJSON2.deserialize = SuperJSON2.defaultInstance.deserialize.bind(SuperJSON2.defaultInstance);
      SuperJSON2.stringify = SuperJSON2.defaultInstance.stringify.bind(SuperJSON2.defaultInstance);
      SuperJSON2.parse = SuperJSON2.defaultInstance.parse.bind(SuperJSON2.defaultInstance);
      SuperJSON2.registerClass = SuperJSON2.defaultInstance.registerClass.bind(SuperJSON2.defaultInstance);
      SuperJSON2.registerSymbol = SuperJSON2.defaultInstance.registerSymbol.bind(SuperJSON2.defaultInstance);
      SuperJSON2.registerCustom = SuperJSON2.defaultInstance.registerCustom.bind(SuperJSON2.defaultInstance);
      SuperJSON2.allowErrorProps = SuperJSON2.defaultInstance.allowErrorProps.bind(SuperJSON2.defaultInstance);
      return SuperJSON2;
    }();
    esm_default = SuperJSON;
    serialize = SuperJSON.serialize;
    deserialize = SuperJSON.deserialize;
    stringify = SuperJSON.stringify;
    parse = SuperJSON.parse;
    registerClass = SuperJSON.registerClass;
    registerCustom = SuperJSON.registerCustom;
    registerSymbol = SuperJSON.registerSymbol;
    allowErrorProps = SuperJSON.allowErrorProps;
  }
});

// node_modules/isomorphic-ws/browser.js
var browser_exports = {};
__export(browser_exports, {
  default: () => browser_default
});
var ws, browser_default;
var init_browser = __esm({
  "node_modules/isomorphic-ws/browser.js"() {
    ws = null;
    if (typeof WebSocket !== "undefined") {
      ws = WebSocket;
    } else if (typeof MozWebSocket !== "undefined") {
      ws = MozWebSocket;
    } else if (typeof global !== "undefined") {
      ws = global.WebSocket || global.MozWebSocket;
    } else if (typeof window !== "undefined") {
      ws = window.WebSocket || window.MozWebSocket;
    } else if (typeof self !== "undefined") {
      ws = self.WebSocket || self.MozWebSocket;
    }
    browser_default = ws;
  }
});

// node_modules/@statelyai/inspect/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@statelyai/inspect/dist/index.js"(exports, module) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export2(src_exports, {
      createBrowserInspector: () => createBrowserInspector,
      createBrowserReceiver: () => createBrowserReceiver,
      createInspector: () => createInspector,
      createSkyInspector: () => createSkyInspector,
      createWebSocketInspector: () => createWebSocketInspector,
      createWebSocketReceiver: () => createWebSocketReceiver
    });
    module.exports = __toCommonJS2(src_exports);
    var import_fast_safe_stringify = __toESM(require_fast_safe_stringify());
    var import_xstate = (init_xstate_development_esm(), __toCommonJS(xstate_development_esm_exports));
    function toEventObject(event) {
      if (typeof event === "string") {
        return { type: event };
      }
      return event;
    }
    var _a;
    var isNode = typeof process !== "undefined" && typeof ((_a = process.versions) == null ? void 0 : _a.node) !== "undefined" && typeof document === "undefined";
    var package_default = {
      devDependencies: {
        "@changesets/changelog-github": "^0.5.0",
        "@changesets/cli": "^2.27.7",
        "@types/jsdom": "^21.1.7",
        "@types/uuid": "^9.0.8",
        jsdom: "^23.2.0",
        tsup: "^8.1.0",
        typescript: "^5.5.3",
        vitest: "^1.6.0",
        xstate: "^5.14.0"
      },
      name: "@statelyai/inspect",
      version: "0.4.0",
      description: "Inspection utilities for state, actors, workflows, and state machines.",
      main: "dist/index.js",
      repository: "https://github.com/statelyai/inspect.git",
      author: "David Khourshid <davidkpiano@gmail.com>",
      license: "MIT",
      dependencies: {
        "fast-safe-stringify": "^2.1.1",
        "isomorphic-ws": "^5.0.0",
        partysocket: "^0.0.25",
        "safe-stable-stringify": "^2.4.3",
        superjson: "^1.13.3",
        uuid: "^9.0.1"
      },
      peerDependencies: {
        xstate: "^5.5.1"
      },
      scripts: {
        build: "tsup src/index.ts --dts",
        watch: "tsup src/index.ts --dts --watch",
        test: "vitest",
        prepublishOnly: "tsup src/index.ts --dts",
        changeset: "changeset",
        release: "changeset publish",
        version: "changeset version",
        dev: "yarn build && ./scripts/dev.sh"
      },
      publishConfig: {
        access: "public"
      },
      packageManager: "pnpm@8.11.0"
    };
    function idleCallback(cb) {
      if (typeof window !== "undefined") {
        const raf = window.requestIdleCallback || window.requestAnimationFrame;
        raf(cb);
      } else {
        setTimeout(cb, 0);
      }
    }
    var import_safe_stable_stringify = __toESM(require_safe_stable_stringify());
    function getRoot(actorRef) {
      let marker = actorRef;
      do {
        marker = marker._parent;
      } while (marker == null ? void 0 : marker._parent);
      return marker;
    }
    function getRootId(actorRefOrId) {
      var _a2;
      const rootActorRef = typeof actorRefOrId === "string" ? void 0 : (_a2 = getRoot(actorRefOrId)) == null ? void 0 : _a2.sessionId;
      return rootActorRef ?? void 0;
    }
    var defaultInspectorOptions = {
      filter: () => true,
      serialize: (event) => event,
      autoStart: true,
      maxDeferredEvents: 200,
      sanitizeEvent: (event) => event,
      sanitizeContext: (context) => context
    };
    function createInspector(adapter, options) {
      function sendAdapter(inspectionEvent) {
        var _a2;
        if ((options == null ? void 0 : options.filter) && !options.filter(inspectionEvent)) {
          return;
        }
        const sanitizedEvent = (options == null ? void 0 : options.sanitizeContext) || (options == null ? void 0 : options.sanitizeEvent) ? inspectionEvent : {
          ...inspectionEvent
        };
        if ((options == null ? void 0 : options.sanitizeContext) && (sanitizedEvent.type === "@xstate.actor" || sanitizedEvent.type === "@xstate.snapshot")) {
          sanitizedEvent.snapshot = {
            ...sanitizedEvent.snapshot,
            // @ts-ignore
            context: options.sanitizeContext(
              // @ts-ignore
              sanitizedEvent.snapshot.context
            )
          };
        }
        if ((options == null ? void 0 : options.sanitizeEvent) && (sanitizedEvent.type === "@xstate.event" || sanitizedEvent.type === "@xstate.snapshot")) {
          sanitizedEvent.event = options.sanitizeEvent(sanitizedEvent.event);
        }
        const serializedEvent = ((_a2 = options == null ? void 0 : options.serialize) == null ? void 0 : _a2.call(options, sanitizedEvent)) ?? sanitizedEvent;
        adapter.send(serializedEvent);
      }
      const inspector = {
        adapter,
        actor: (actorRef, snapshot, info) => {
          var _a2, _b;
          const sessionId = typeof actorRef === "string" ? actorRef : actorRef.sessionId;
          const definitionObject = (_a2 = actorRef == null ? void 0 : actorRef.logic) == null ? void 0 : _a2.config;
          const definition = definitionObject ? (0, import_safe_stable_stringify.default)(definitionObject) : void 0;
          const rootId = (info == null ? void 0 : info.rootId) ?? typeof actorRef === "string" ? void 0 : getRootId(actorRef);
          const parentId = (info == null ? void 0 : info.parentId) ?? typeof actorRef === "string" ? void 0 : (_b = actorRef._parent) == null ? void 0 : _b.sessionId;
          const name = definitionObject ? definitionObject.id : sessionId;
          sendAdapter({
            type: "@xstate.actor",
            name,
            sessionId,
            createdAt: Date.now().toString(),
            _version: package_default.version,
            rootId,
            parentId,
            id: null,
            definition,
            snapshot: snapshot ?? { status: "active" }
          });
        },
        event: (target, event, info) => {
          const sessionId = typeof target === "string" ? target : target.sessionId;
          const sourceId = !(info == null ? void 0 : info.source) ? void 0 : typeof info.source === "string" ? info.source : info.source.sessionId;
          sendAdapter({
            type: "@xstate.event",
            sourceId,
            sessionId,
            event: toEventObject(event),
            id: Math.random().toString(),
            createdAt: Date.now().toString(),
            rootId: "anonymous",
            _version: package_default.version
          });
        },
        snapshot: (actor, snapshot, info) => {
          const sessionId = typeof actor === "string" ? actor : actor.sessionId;
          sendAdapter({
            type: "@xstate.snapshot",
            snapshot: {
              status: "active",
              ...snapshot
            },
            event: (info == null ? void 0 : info.event) ?? { type: "" },
            sessionId,
            id: null,
            createdAt: Date.now().toString(),
            rootId: "anonymous",
            _version: package_default.version
          });
        },
        inspect: {
          next: (event) => {
            idleCallback(function inspectNext() {
              const convertedEvent = convertXStateEvent(event);
              if (convertedEvent) {
                sendAdapter(convertedEvent);
              }
            });
          }
        },
        start() {
          var _a2;
          (_a2 = adapter.start) == null ? void 0 : _a2.call(adapter);
        },
        stop() {
          var _a2;
          (_a2 = adapter.stop) == null ? void 0 : _a2.call(adapter);
        }
      };
      return inspector;
    }
    function convertXStateEvent(inspectionEvent) {
      var _a2, _b;
      switch (inspectionEvent.type) {
        case "@xstate.actor": {
          const actorRef = inspectionEvent.actorRef;
          const logic = actorRef == null ? void 0 : actorRef.logic;
          const definitionObject = logic == null ? void 0 : logic.config;
          let name = actorRef.id;
          if (name === actorRef.sessionId && definitionObject) {
            name = definitionObject.id;
          }
          const definitionString = typeof definitionObject === "object" ? (0, import_safe_stable_stringify.default)(definitionObject, (_key, value) => {
            if (typeof value === "function") {
              return { type: value.name };
            }
            return value;
          }) : (0, import_safe_stable_stringify.default)({
            id: name
          });
          return {
            name,
            type: "@xstate.actor",
            definition: definitionString,
            _version: package_default.version,
            createdAt: Date.now().toString(),
            id: null,
            rootId: inspectionEvent.rootId,
            parentId: (_a2 = inspectionEvent.actorRef._parent) == null ? void 0 : _a2.sessionId,
            sessionId: inspectionEvent.actorRef.sessionId,
            snapshot: inspectionEvent.actorRef.getSnapshot()
          };
        }
        case "@xstate.event": {
          return {
            type: "@xstate.event",
            event: inspectionEvent.event,
            sourceId: (_b = inspectionEvent.sourceRef) == null ? void 0 : _b.sessionId,
            // sessionId: inspectionEvent.targetRef.sessionId,
            sessionId: inspectionEvent.actorRef.sessionId,
            _version: package_default.version,
            createdAt: Date.now().toString(),
            id: null,
            rootId: inspectionEvent.rootId
          };
        }
        case "@xstate.snapshot": {
          return {
            type: "@xstate.snapshot",
            event: inspectionEvent.event,
            snapshot: JSON.parse((0, import_safe_stable_stringify.default)(inspectionEvent.snapshot)),
            sessionId: inspectionEvent.actorRef.sessionId,
            _version: package_default.version,
            createdAt: Date.now().toString(),
            id: null,
            rootId: inspectionEvent.rootId
          };
        }
        default: {
          if (inspectionEvent.type.startsWith("@xstate.")) {
            return void 0;
          }
          console.warn(
            `Unhandled inspection event type: ${inspectionEvent.type}`
          );
          return void 0;
        }
      }
    }
    var UselessAdapter = class {
      constructor() {
      }
      start() {
      }
      stop() {
      }
      send(_event) {
      }
    };
    var CONNECTION_EVENT = "@statelyai.connected";
    function isEventObject(event) {
      return typeof event === "object" && event !== null && typeof event.type === "string";
    }
    function isStatelyInspectionEvent(event) {
      return typeof event === "object" && event !== null && typeof event.type === "string" && typeof event._version === "string";
    }
    function createBrowserInspector(options) {
      const resolvedWindow = (options == null ? void 0 : options.window) ?? (typeof window === "undefined" ? void 0 : window);
      if (!resolvedWindow) {
        console.error("Window does not exist; inspector cannot be started.");
        return new UselessAdapter();
      }
      const resolvedOptions = {
        ...defaultInspectorOptions,
        url: "https://stately.ai/inspect",
        filter: () => true,
        serialize: (inspectionEvent) => JSON.parse((0, import_fast_safe_stringify.default)(inspectionEvent)),
        autoStart: true,
        iframe: null,
        ...options,
        window: resolvedWindow
      };
      const adapter = new BrowserAdapter(resolvedOptions);
      const inspector = createInspector(adapter, resolvedOptions);
      if (resolvedOptions.autoStart) {
        inspector.start();
      }
      return inspector;
    }
    var defaultBrowserReceiverOptions = {
      replayCount: 0,
      window: typeof window !== "undefined" ? window : void 0
    };
    function createBrowserReceiver(options) {
      const resolvedOptions = {
        ...defaultBrowserReceiverOptions,
        ...options
      };
      const browserWindow = resolvedOptions.window;
      const targetWindow = browserWindow.self === browserWindow.top ? browserWindow.opener : browserWindow.parent;
      const observers = /* @__PURE__ */ new Set();
      browserWindow.addEventListener("message", (event) => {
        if (!isStatelyInspectionEvent(event.data)) {
          return;
        }
        observers.forEach((observer) => {
          var _a2;
          return (_a2 = observer.next) == null ? void 0 : _a2.call(observer, event.data);
        });
      });
      const receiver = {
        subscribe(observerOrFn) {
          const observer = (0, import_xstate.toObserver)(observerOrFn);
          observers.add(observer);
          return {
            unsubscribe() {
              observers.delete(observer);
            }
          };
        }
      };
      if (targetWindow) {
        targetWindow.postMessage(
          {
            type: CONNECTION_EVENT
          },
          "*"
        );
      }
      return receiver;
    }
    var BrowserAdapter = class {
      constructor(options) {
        __publicField(this, "status", "disconnected");
        __publicField(this, "deferredEvents", []);
        __publicField(this, "targetWindow", null);
        this.options = options;
      }
      start() {
        var _a2;
        this.targetWindow = this.options.iframe ? null : this.options.window.open(String(this.options.url), "xstateinspector");
        if (this.options.iframe) {
          this.options.iframe.addEventListener("load", () => {
            var _a3;
            this.targetWindow = ((_a3 = this.options.iframe) == null ? void 0 : _a3.contentWindow) ?? null;
          });
          (_a2 = this.options.iframe) == null ? void 0 : _a2.setAttribute("src", String(this.options.url));
        }
        this.options.window.addEventListener("message", (event) => {
          if (isEventObject(event.data) && event.data.type === "@statelyai.connected") {
            this.status = "connected";
            this.deferredEvents.forEach((event2) => {
              var _a3;
              const serializedEvent = this.options.serialize(event2);
              (_a3 = this.targetWindow) == null ? void 0 : _a3.postMessage(serializedEvent, "*");
            });
          }
        });
      }
      stop() {
        var _a2;
        (_a2 = this.targetWindow) == null ? void 0 : _a2.postMessage({ type: "@statelyai.disconnected" }, "*");
        this.status = "disconnected";
      }
      send(event) {
        var _a2;
        const shouldSendEvent = this.options.filter(event);
        if (!shouldSendEvent) {
          return;
        }
        if (this.options.send) {
          this.options.send(event);
        } else if (this.status === "connected") {
          const serializedEvent = this.options.serialize(event);
          (_a2 = this.targetWindow) == null ? void 0 : _a2.postMessage(serializedEvent, "*");
        }
        this.deferredEvents.push(event);
        if (this.deferredEvents.length > this.options.maxDeferredEvents) {
          this.deferredEvents.shift();
        }
      }
    };
    var import_partysocket = __toESM(require_dist());
    var import_superjson = (init_esm(), __toCommonJS(esm_exports));
    var import_uuid = require_commonjs_browser();
    var isDevMode = false;
    function createSkyInspector(options = {}) {
      const { host, apiBaseURL } = {
        host: isDevMode ? "localhost:1999" : "stately-sky-beta.mellson.partykit.dev",
        apiBaseURL: isDevMode ? "http://localhost:3000/registry/api/sky" : "https://stately.ai/registry/api/sky"
      };
      const server = apiBaseURL.replace("/api/sky", "");
      const { apiKey, onerror, ...inspectorOptions } = options;
      const sessionId = (0, import_uuid.v4)();
      const room = `inspect-${sessionId}`;
      const socket = new import_partysocket.default({
        host,
        room,
        WebSocket: isNode ? (init_browser(), __toCommonJS(browser_exports)) : void 0
      });
      const liveInspectUrl = `${server}/inspect/${sessionId}`;
      socket.onerror = onerror ?? console.error;
      socket.onopen = () => {
        console.log("Connected to Sky, link to your live inspect session:");
        console.log(liveInspectUrl);
      };
      if (isNode) {
        return createInspector({
          ...inspectorOptions,
          send(event) {
            const skyEvent = apiKey ? { apiKey, ...event } : event;
            socket.send((0, import_superjson.stringify)(skyEvent));
          }
        });
      } else {
        return createBrowserInspector({
          ...inspectorOptions,
          url: liveInspectUrl,
          send(event) {
            const skyEvent = apiKey ? { apiKey, ...event } : event;
            socket.send((0, import_superjson.stringify)(skyEvent));
          }
        });
      }
    }
    var import_isomorphic_ws = __toESM((init_browser(), __toCommonJS(browser_exports)));
    var import_safe_stable_stringify2 = __toESM(require_safe_stable_stringify());
    var import_xstate2 = (init_xstate_development_esm(), __toCommonJS(xstate_development_esm_exports));
    var WebSocketAdapter = class {
      constructor(options) {
        __publicField(this, "ws");
        __publicField(this, "status", "closed");
        __publicField(this, "deferredEvents", []);
        __publicField(this, "options");
        this.options = {
          ...defaultInspectorOptions,
          filter: () => true,
          serialize: (inspectionEvent) => JSON.parse((0, import_safe_stable_stringify2.default)(inspectionEvent)),
          autoStart: true,
          url: "ws://localhost:8080",
          ...options
        };
      }
      start() {
        const start = () => {
          this.ws = new import_isomorphic_ws.default(this.options.url);
          this.ws.onopen = () => {
            console.log("websocket open");
            this.status = "open";
            this.deferredEvents.forEach((inspectionEvent) => {
              const preSerializedEvent = defaultInspectorOptions.serialize(inspectionEvent);
              const serializedEvent = this.options.serialize(preSerializedEvent);
              this.ws.send((0, import_safe_stable_stringify2.default)(serializedEvent));
            });
          };
          this.ws.onclose = () => {
            console.log("websocket closed");
          };
          this.ws.onerror = async (event) => {
            console.error("websocket error", event);
            await new Promise((res) => setTimeout(res, 5e3));
            console.warn("restarting");
            start();
          };
          this.ws.onmessage = (event) => {
            if (typeof event.data !== "string") {
              return;
            }
            console.log("message", event.data);
          };
        };
        start();
      }
      stop() {
        this.ws.close();
        this.status = "closed";
      }
      send(inspectionEvent) {
        if (this.status === "open") {
          this.ws.send((0, import_safe_stable_stringify2.default)(inspectionEvent));
        } else {
          this.deferredEvents.push(inspectionEvent);
          if (this.deferredEvents.length > this.options.maxDeferredEvents) {
            this.deferredEvents.shift();
          }
        }
      }
    };
    function createWebSocketInspector(options) {
      const adapter = new WebSocketAdapter(options);
      const inspector = createInspector(adapter, options);
      return inspector;
    }
    function createWebSocketReceiver(options) {
      const resolvedOptions = {
        server: "ws://localhost:8080",
        ...options
      };
      const observers = /* @__PURE__ */ new Set();
      const ws2 = new import_isomorphic_ws.default(resolvedOptions.server);
      ws2.onopen = () => {
        console.log("websocket open");
        ws2.onmessage = (event) => {
          if (typeof event.data !== "string") {
            return;
          }
          console.log("message", event.data);
          const eventData = JSON.parse(event.data);
          observers.forEach((observer) => {
            var _a2;
            (_a2 = observer.next) == null ? void 0 : _a2.call(observer, eventData);
          });
        };
      };
      const receiver = {
        subscribe(observerOrFn) {
          const observer = (0, import_xstate2.toObserver)(observerOrFn);
          observers.add(observer);
          return {
            unsubscribe() {
              observers.delete(observer);
            }
          };
        }
      };
      return receiver;
    }
  }
});
export default require_dist2();
/*! Bundled license information:

partysocket/dist/index.js:
  (*!
   * Reconnecting WebSocket
   * by Pedro Ladaria <pedro.ladaria@gmail.com>
   * https://github.com/pladaria/reconnecting-websocket
   * License MIT
   *)
*/
//# sourceMappingURL=@statelyai_inspect.js.map
