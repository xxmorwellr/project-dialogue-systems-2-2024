"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createBrowserInspector: () => createBrowserInspector,
  createBrowserReceiver: () => createBrowserReceiver,
  createInspector: () => createInspector,
  createSkyInspector: () => createSkyInspector,
  createWebSocketInspector: () => createWebSocketInspector,
  createWebSocketReceiver: () => createWebSocketReceiver
});
module.exports = __toCommonJS(src_exports);

// src/browser.ts
var import_fast_safe_stringify = __toESM(require("fast-safe-stringify"));
var import_xstate = require("xstate");

// src/utils.ts
function toEventObject(event) {
  if (typeof event === "string") {
    return { type: event };
  }
  return event;
}
var isNode = typeof process !== "undefined" && typeof process.versions?.node !== "undefined" && typeof document === "undefined";

// package.json
var package_default = {
  devDependencies: {
    "@changesets/changelog-github": "^0.5.0",
    "@changesets/cli": "^2.27.7",
    "@types/jsdom": "^21.1.7",
    "@types/uuid": "^9.0.8",
    jsdom: "^23.2.0",
    tsup: "^8.1.0",
    typescript: "^5.5.3",
    vitest: "^1.6.0",
    xstate: "^5.14.0"
  },
  name: "@statelyai/inspect",
  version: "0.4.0",
  description: "Inspection utilities for state, actors, workflows, and state machines.",
  main: "dist/index.js",
  repository: "https://github.com/statelyai/inspect.git",
  author: "David Khourshid <davidkpiano@gmail.com>",
  license: "MIT",
  dependencies: {
    "fast-safe-stringify": "^2.1.1",
    "isomorphic-ws": "^5.0.0",
    partysocket: "^0.0.25",
    "safe-stable-stringify": "^2.4.3",
    superjson: "^1.13.3",
    uuid: "^9.0.1"
  },
  peerDependencies: {
    xstate: "^5.5.1"
  },
  scripts: {
    build: "tsup src/index.ts --dts",
    watch: "tsup src/index.ts --dts --watch",
    test: "vitest",
    prepublishOnly: "tsup src/index.ts --dts",
    changeset: "changeset",
    release: "changeset publish",
    version: "changeset version",
    dev: "yarn build && ./scripts/dev.sh"
  },
  publishConfig: {
    access: "public"
  },
  packageManager: "pnpm@8.11.0"
};

// src/idleCallback.ts
function idleCallback(cb) {
  if (typeof window !== "undefined") {
    const raf = window.requestIdleCallback || window.requestAnimationFrame;
    raf(cb);
  } else {
    setTimeout(cb, 0);
  }
}

// src/createInspector.ts
var import_safe_stable_stringify = __toESM(require("safe-stable-stringify"));
function getRoot(actorRef) {
  let marker = actorRef;
  do {
    marker = marker._parent;
  } while (marker?._parent);
  return marker;
}
function getRootId(actorRefOrId) {
  const rootActorRef = typeof actorRefOrId === "string" ? void 0 : getRoot(actorRefOrId)?.sessionId;
  return rootActorRef ?? void 0;
}
var defaultInspectorOptions = {
  filter: () => true,
  serialize: (event) => event,
  autoStart: true,
  maxDeferredEvents: 200,
  sanitizeEvent: (event) => event,
  sanitizeContext: (context) => context
};
function createInspector(adapter, options) {
  function sendAdapter(inspectionEvent) {
    if (options?.filter && !options.filter(inspectionEvent)) {
      return;
    }
    const sanitizedEvent = options?.sanitizeContext || options?.sanitizeEvent ? inspectionEvent : {
      ...inspectionEvent
    };
    if (options?.sanitizeContext && (sanitizedEvent.type === "@xstate.actor" || sanitizedEvent.type === "@xstate.snapshot")) {
      sanitizedEvent.snapshot = {
        ...sanitizedEvent.snapshot,
        // @ts-ignore
        context: options.sanitizeContext(
          // @ts-ignore
          sanitizedEvent.snapshot.context
        )
      };
    }
    if (options?.sanitizeEvent && (sanitizedEvent.type === "@xstate.event" || sanitizedEvent.type === "@xstate.snapshot")) {
      sanitizedEvent.event = options.sanitizeEvent(sanitizedEvent.event);
    }
    const serializedEvent = options?.serialize?.(sanitizedEvent) ?? sanitizedEvent;
    adapter.send(serializedEvent);
  }
  const inspector = {
    adapter,
    actor: (actorRef, snapshot, info) => {
      const sessionId = typeof actorRef === "string" ? actorRef : actorRef.sessionId;
      const definitionObject = actorRef?.logic?.config;
      const definition = definitionObject ? (0, import_safe_stable_stringify.default)(definitionObject) : void 0;
      const rootId = info?.rootId ?? typeof actorRef === "string" ? void 0 : getRootId(actorRef);
      const parentId = info?.parentId ?? typeof actorRef === "string" ? void 0 : actorRef._parent?.sessionId;
      const name = definitionObject ? definitionObject.id : sessionId;
      sendAdapter({
        type: "@xstate.actor",
        name,
        sessionId,
        createdAt: Date.now().toString(),
        _version: package_default.version,
        rootId,
        parentId,
        id: null,
        definition,
        snapshot: snapshot ?? { status: "active" }
      });
    },
    event: (target, event, info) => {
      const sessionId = typeof target === "string" ? target : target.sessionId;
      const sourceId = !info?.source ? void 0 : typeof info.source === "string" ? info.source : info.source.sessionId;
      sendAdapter({
        type: "@xstate.event",
        sourceId,
        sessionId,
        event: toEventObject(event),
        id: Math.random().toString(),
        createdAt: Date.now().toString(),
        rootId: "anonymous",
        _version: package_default.version
      });
    },
    snapshot: (actor, snapshot, info) => {
      const sessionId = typeof actor === "string" ? actor : actor.sessionId;
      sendAdapter({
        type: "@xstate.snapshot",
        snapshot: {
          status: "active",
          ...snapshot
        },
        event: info?.event ?? { type: "" },
        sessionId,
        id: null,
        createdAt: Date.now().toString(),
        rootId: "anonymous",
        _version: package_default.version
      });
    },
    inspect: {
      next: (event) => {
        idleCallback(function inspectNext() {
          const convertedEvent = convertXStateEvent(event);
          if (convertedEvent) {
            sendAdapter(convertedEvent);
          }
        });
      }
    },
    start() {
      adapter.start?.();
    },
    stop() {
      adapter.stop?.();
    }
  };
  return inspector;
}
function convertXStateEvent(inspectionEvent) {
  switch (inspectionEvent.type) {
    case "@xstate.actor": {
      const actorRef = inspectionEvent.actorRef;
      const logic = actorRef?.logic;
      const definitionObject = logic?.config;
      let name = actorRef.id;
      if (name === actorRef.sessionId && definitionObject) {
        name = definitionObject.id;
      }
      const definitionString = typeof definitionObject === "object" ? (0, import_safe_stable_stringify.default)(definitionObject, (_key, value) => {
        if (typeof value === "function") {
          return { type: value.name };
        }
        return value;
      }) : (0, import_safe_stable_stringify.default)({
        id: name
      });
      return {
        name,
        type: "@xstate.actor",
        definition: definitionString,
        _version: package_default.version,
        createdAt: Date.now().toString(),
        id: null,
        rootId: inspectionEvent.rootId,
        parentId: inspectionEvent.actorRef._parent?.sessionId,
        sessionId: inspectionEvent.actorRef.sessionId,
        snapshot: inspectionEvent.actorRef.getSnapshot()
      };
    }
    case "@xstate.event": {
      return {
        type: "@xstate.event",
        event: inspectionEvent.event,
        sourceId: inspectionEvent.sourceRef?.sessionId,
        // sessionId: inspectionEvent.targetRef.sessionId,
        sessionId: inspectionEvent.actorRef.sessionId,
        _version: package_default.version,
        createdAt: Date.now().toString(),
        id: null,
        rootId: inspectionEvent.rootId
      };
    }
    case "@xstate.snapshot": {
      return {
        type: "@xstate.snapshot",
        event: inspectionEvent.event,
        snapshot: JSON.parse((0, import_safe_stable_stringify.default)(inspectionEvent.snapshot)),
        sessionId: inspectionEvent.actorRef.sessionId,
        _version: package_default.version,
        createdAt: Date.now().toString(),
        id: null,
        rootId: inspectionEvent.rootId
      };
    }
    default: {
      if (inspectionEvent.type.startsWith("@xstate.")) {
        return void 0;
      }
      console.warn(
        `Unhandled inspection event type: ${inspectionEvent.type}`
      );
      return void 0;
    }
  }
}

// src/useless.ts
var UselessAdapter = class {
  constructor() {
  }
  start() {
  }
  stop() {
  }
  send(_event) {
  }
};

// src/browser.ts
var CONNECTION_EVENT = "@statelyai.connected";
function isEventObject(event) {
  return typeof event === "object" && event !== null && typeof event.type === "string";
}
function isStatelyInspectionEvent(event) {
  return typeof event === "object" && event !== null && typeof event.type === "string" && typeof event._version === "string";
}
function createBrowserInspector(options) {
  const resolvedWindow = options?.window ?? (typeof window === "undefined" ? void 0 : window);
  if (!resolvedWindow) {
    console.error("Window does not exist; inspector cannot be started.");
    return new UselessAdapter();
  }
  const resolvedOptions = {
    ...defaultInspectorOptions,
    url: "https://stately.ai/inspect",
    filter: () => true,
    serialize: (inspectionEvent) => JSON.parse((0, import_fast_safe_stringify.default)(inspectionEvent)),
    autoStart: true,
    iframe: null,
    ...options,
    window: resolvedWindow
  };
  const adapter = new BrowserAdapter(resolvedOptions);
  const inspector = createInspector(adapter, resolvedOptions);
  if (resolvedOptions.autoStart) {
    inspector.start();
  }
  return inspector;
}
var defaultBrowserReceiverOptions = {
  replayCount: 0,
  window: typeof window !== "undefined" ? window : void 0
};
function createBrowserReceiver(options) {
  const resolvedOptions = {
    ...defaultBrowserReceiverOptions,
    ...options
  };
  const browserWindow = resolvedOptions.window;
  const targetWindow = browserWindow.self === browserWindow.top ? browserWindow.opener : browserWindow.parent;
  const observers = /* @__PURE__ */ new Set();
  browserWindow.addEventListener("message", (event) => {
    if (!isStatelyInspectionEvent(event.data)) {
      return;
    }
    observers.forEach((observer) => observer.next?.(event.data));
  });
  const receiver = {
    subscribe(observerOrFn) {
      const observer = (0, import_xstate.toObserver)(observerOrFn);
      observers.add(observer);
      return {
        unsubscribe() {
          observers.delete(observer);
        }
      };
    }
  };
  if (targetWindow) {
    targetWindow.postMessage(
      {
        type: CONNECTION_EVENT
      },
      "*"
    );
  }
  return receiver;
}
var BrowserAdapter = class {
  constructor(options) {
    this.options = options;
  }
  status = "disconnected";
  deferredEvents = [];
  targetWindow = null;
  start() {
    this.targetWindow = this.options.iframe ? null : this.options.window.open(String(this.options.url), "xstateinspector");
    if (this.options.iframe) {
      this.options.iframe.addEventListener("load", () => {
        this.targetWindow = this.options.iframe?.contentWindow ?? null;
      });
      this.options.iframe?.setAttribute("src", String(this.options.url));
    }
    this.options.window.addEventListener("message", (event) => {
      if (isEventObject(event.data) && event.data.type === "@statelyai.connected") {
        this.status = "connected";
        this.deferredEvents.forEach((event2) => {
          const serializedEvent = this.options.serialize(event2);
          this.targetWindow?.postMessage(serializedEvent, "*");
        });
      }
    });
  }
  stop() {
    this.targetWindow?.postMessage({ type: "@statelyai.disconnected" }, "*");
    this.status = "disconnected";
  }
  send(event) {
    const shouldSendEvent = this.options.filter(event);
    if (!shouldSendEvent) {
      return;
    }
    if (this.options.send) {
      this.options.send(event);
    } else if (this.status === "connected") {
      const serializedEvent = this.options.serialize(event);
      this.targetWindow?.postMessage(serializedEvent, "*");
    }
    this.deferredEvents.push(event);
    if (this.deferredEvents.length > this.options.maxDeferredEvents) {
      this.deferredEvents.shift();
    }
  }
};

// src/createSkyInspector.ts
var import_partysocket = __toESM(require("partysocket"));
var import_superjson = require("superjson");
var import_uuid = require("uuid");
var isDevMode = false;
function createSkyInspector(options = {}) {
  const { host, apiBaseURL } = {
    host: isDevMode ? "localhost:1999" : "stately-sky-beta.mellson.partykit.dev",
    apiBaseURL: isDevMode ? "http://localhost:3000/registry/api/sky" : "https://stately.ai/registry/api/sky"
  };
  const server = apiBaseURL.replace("/api/sky", "");
  const { apiKey, onerror, ...inspectorOptions } = options;
  const sessionId = (0, import_uuid.v4)();
  const room = `inspect-${sessionId}`;
  const socket = new import_partysocket.default({
    host,
    room,
    WebSocket: isNode ? require("isomorphic-ws") : void 0
  });
  const liveInspectUrl = `${server}/inspect/${sessionId}`;
  socket.onerror = onerror ?? console.error;
  socket.onopen = () => {
    console.log("Connected to Sky, link to your live inspect session:");
    console.log(liveInspectUrl);
  };
  if (isNode) {
    return createInspector({
      ...inspectorOptions,
      send(event) {
        const skyEvent = apiKey ? { apiKey, ...event } : event;
        socket.send((0, import_superjson.stringify)(skyEvent));
      }
    });
  } else {
    return createBrowserInspector({
      ...inspectorOptions,
      url: liveInspectUrl,
      send(event) {
        const skyEvent = apiKey ? { apiKey, ...event } : event;
        socket.send((0, import_superjson.stringify)(skyEvent));
      }
    });
  }
}

// src/webSocket.ts
var import_isomorphic_ws = __toESM(require("isomorphic-ws"));
var import_safe_stable_stringify2 = __toESM(require("safe-stable-stringify"));
var import_xstate2 = require("xstate");
var WebSocketAdapter = class {
  ws;
  status = "closed";
  deferredEvents = [];
  options;
  constructor(options) {
    this.options = {
      ...defaultInspectorOptions,
      filter: () => true,
      serialize: (inspectionEvent) => JSON.parse((0, import_safe_stable_stringify2.default)(inspectionEvent)),
      autoStart: true,
      url: "ws://localhost:8080",
      ...options
    };
  }
  start() {
    const start = () => {
      this.ws = new import_isomorphic_ws.default(this.options.url);
      this.ws.onopen = () => {
        console.log("websocket open");
        this.status = "open";
        this.deferredEvents.forEach((inspectionEvent) => {
          const preSerializedEvent = defaultInspectorOptions.serialize(inspectionEvent);
          const serializedEvent = this.options.serialize(preSerializedEvent);
          this.ws.send((0, import_safe_stable_stringify2.default)(serializedEvent));
        });
      };
      this.ws.onclose = () => {
        console.log("websocket closed");
      };
      this.ws.onerror = async (event) => {
        console.error("websocket error", event);
        await new Promise((res) => setTimeout(res, 5e3));
        console.warn("restarting");
        start();
      };
      this.ws.onmessage = (event) => {
        if (typeof event.data !== "string") {
          return;
        }
        console.log("message", event.data);
      };
    };
    start();
  }
  stop() {
    this.ws.close();
    this.status = "closed";
  }
  send(inspectionEvent) {
    if (this.status === "open") {
      this.ws.send((0, import_safe_stable_stringify2.default)(inspectionEvent));
    } else {
      this.deferredEvents.push(inspectionEvent);
      if (this.deferredEvents.length > this.options.maxDeferredEvents) {
        this.deferredEvents.shift();
      }
    }
  }
};
function createWebSocketInspector(options) {
  const adapter = new WebSocketAdapter(options);
  const inspector = createInspector(adapter, options);
  return inspector;
}
function createWebSocketReceiver(options) {
  const resolvedOptions = {
    server: "ws://localhost:8080",
    ...options
  };
  const observers = /* @__PURE__ */ new Set();
  const ws = new import_isomorphic_ws.default(resolvedOptions.server);
  ws.onopen = () => {
    console.log("websocket open");
    ws.onmessage = (event) => {
      if (typeof event.data !== "string") {
        return;
      }
      console.log("message", event.data);
      const eventData = JSON.parse(event.data);
      observers.forEach((observer) => {
        observer.next?.(eventData);
      });
    };
  };
  const receiver = {
    subscribe(observerOrFn) {
      const observer = (0, import_xstate2.toObserver)(observerOrFn);
      observers.add(observer);
      return {
        unsubscribe() {
          observers.delete(observer);
        }
      };
    }
  };
  return receiver;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createBrowserInspector,
  createBrowserReceiver,
  createInspector,
  createSkyInspector,
  createWebSocketInspector,
  createWebSocketReceiver
});
